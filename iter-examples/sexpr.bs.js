// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Iter$ReasonmlDemoIterators = require("../src/lib/iter/Iter.bs.js");

function iter(f, s) {
  if (s.TAG === /* Atom */0) {
    return Curry._1(f, {
                NAME: "Atom",
                VAL: s._0
              });
  }
  Curry._1(f, "Open");
  iter_list(f, s._0);
  return Curry._1(f, "Close");
}

function iter_list(f, _l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    iter(f, l.hd);
    _l = l.tl;
    continue ;
  };
}

function traverse(s) {
  return Iter$ReasonmlDemoIterators.from_iter(function (k) {
              return iter(k, s);
            });
}

function validate(seq) {
  var depth = {
    contents: 0
  };
  return function (param) {
    return Iter$ReasonmlDemoIterators.map((function (tok) {
                  if (tok !== "Close") {
                    if (tok === "Open") {
                      depth.contents = depth.contents + 1 | 0;
                      return tok;
                    } else {
                      return tok;
                    }
                  }
                  if (depth.contents === 0) {
                    throw {
                          RE_EXN_ID: "Invalid_argument",
                          _1: "wrong parenthesing",
                          Error: new Error()
                        };
                  }
                  depth.contents = depth.contents - 1 | 0;
                  return tok;
                }), seq, param);
  };
}

function lex(input) {
  return Iter$ReasonmlDemoIterators.from_iter(function (k) {
              var in_word = {
                contents: false
              };
              var buf = $$Buffer.create(128);
              var flush_word = function (param) {
                if (!in_word.contents) {
                  return ;
                }
                var word = $$Buffer.contents(buf);
                $$Buffer.clear(buf);
                in_word.contents = false;
                return Curry._1(k, {
                            NAME: "Atom",
                            VAL: word
                          });
              };
              var next = function (c) {
                if (c >= 11) {
                  switch (c) {
                    case 32 :
                        return flush_word(undefined);
                    case 33 :
                    case 34 :
                    case 35 :
                    case 36 :
                    case 37 :
                    case 38 :
                    case 39 :
                        break;
                    case 40 :
                        return Curry._1(k, "Open");
                    case 41 :
                        flush_word(undefined);
                        return Curry._1(k, "Close");
                    default:
                      
                  }
                } else if (c >= 9) {
                  return flush_word(undefined);
                }
                in_word.contents = true;
                return $$Buffer.add_char(buf, c);
              };
              return Iter$ReasonmlDemoIterators.iter(next, input);
            });
}

function of_seq(seq) {
  var k = function (stack, token) {
    if (typeof token === "string") {
      if (token === "Open") {
        return {
                hd: "Open",
                tl: stack
              };
      } else {
        var _acc = /* [] */0;
        var _stack = stack;
        while(true) {
          var stack$1 = _stack;
          var acc = _acc;
          if (stack$1) {
            var match = stack$1.hd;
            if (typeof match === "string") {
              if (match === "Open") {
                return {
                        hd: {
                          NAME: "Expr",
                          VAL: {
                            TAG: /* List */1,
                            _0: acc
                          }
                        },
                        tl: stack$1.tl
                      };
              }
              
            } else if (match.NAME === "Expr") {
              _stack = stack$1.tl;
              _acc = {
                hd: match.VAL,
                tl: acc
              };
              continue ;
            }
            
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "sexpr.re",
                  137,
                  11
                ],
                Error: new Error()
              };
        };
      }
    } else {
      return {
              hd: {
                NAME: "Expr",
                VAL: {
                  TAG: /* Atom */0,
                  _0: token.VAL
                }
              },
              tl: stack
            };
    }
  };
  var stack = Iter$ReasonmlDemoIterators.fold(k, /* [] */0, seq);
  if (!stack) {
    return Pervasives.failwith("no Sexpr could be parsed");
  }
  var match = stack.hd;
  if (typeof match === "string" || !(match.NAME === "Expr" && !stack.tl)) {
    return Pervasives.failwith("too many elements on the stack");
  } else {
    return match.VAL;
  }
}

function pp_token(formatter, token) {
  if (typeof token === "string") {
    if (token === "Open") {
      return Format.fprintf(formatter, /* Format */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: /* End_of_format */0,
                        _1: ""
                      }
                    },
                    _1: {
                      TAG: /* Char_literal */12,
                      _0: /* '(' */40,
                      _1: /* End_of_format */0
                    }
                  },
                  _1: "@[("
                });
    } else {
      return Format.fprintf(formatter, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* ')' */41,
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: /* Close_box */0,
                      _1: /* End_of_format */0
                    }
                  },
                  _1: ")@]"
                });
    }
  } else {
    return Format.pp_print_string(formatter, token.VAL);
  }
}

function pp_tokens(formatter, tokens) {
  var first = {
    contents: true
  };
  var last = {
    contents: false
  };
  return Iter$ReasonmlDemoIterators.iter((function (token) {
                if (token === "Close") {
                  first.contents = false;
                  last.contents = true;
                } else if (token === "Open") {
                  if (!first.contents) {
                    Format.fprintf(formatter, /* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ' ' */32,
                            _1: /* End_of_format */0
                          },
                          _1: " "
                        });
                  }
                  first.contents = true;
                } else if (first.contents) {
                  first.contents = false;
                } else {
                  Format.fprintf(formatter, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* ' ' */32,
                          _1: /* End_of_format */0
                        },
                        _1: " "
                      });
                }
                pp_token(formatter, token);
                if (last.contents) {
                  last.contents = false;
                  return ;
                }
                
              }), tokens);
}

function pp_sexpr(indentOpt, formatter, s) {
  var indent = indentOpt !== undefined ? indentOpt : false;
  if (indent) {
    return Curry._2(Format.fprintf(formatter, /* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<hov 4>",
                            _1: /* End_of_format */0
                          },
                          _1: "<hov 4>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "@[<hov 4>%a@]"
                  }), pp_tokens, Iter$ReasonmlDemoIterators.from_iter(function (k) {
                    return iter(k, s);
                  }));
  } else {
    return pp_tokens(formatter, Iter$ReasonmlDemoIterators.from_iter(function (k) {
                    return iter(k, s);
                  }));
  }
}

function output_seq(name, subexpr, k) {
  Curry._1(k, "Open");
  Curry._1(k, {
        NAME: "Atom",
        VAL: name
      });
  Iter$ReasonmlDemoIterators.iter(k, subexpr);
  return Curry._1(k, "Close");
}

function output_str(name, str, k) {
  Curry._1(k, "Open");
  Curry._1(k, {
        NAME: "Atom",
        VAL: name
      });
  Curry._1(k, {
        NAME: "Atom",
        VAL: str
      });
  return Curry._1(k, "Close");
}

var ParseFailure = /* @__PURE__ */Caml_exceptions.create("Sexpr-ReasonmlDemoIterators.ParseFailure");

function $great$great$eq(p, f) {
  return {
          TAG: /* Bind */3,
          _0: [
            p,
            f
          ]
        };
}

function $great$great(p, p$prime) {
  return {
          TAG: /* Bind */3,
          _0: [
            p,
            (function (param) {
                return p$prime;
              })
          ]
        };
}

function $$return(x) {
  return {
          TAG: /* Return */0,
          _0: x
        };
}

function fail(reason) {
  return {
          TAG: /* Fail */4,
          _0: reason
        };
}

function one(f) {
  return {
          TAG: /* One */1,
          _0: f
        };
}

var skip = {
  TAG: /* One */1,
  _0: (function (param) {
      
    })
};

function lookahead(f) {
  return {
          TAG: /* Zero */2,
          _0: f
        };
}

var left = {
  TAG: /* One */1,
  _0: (function (param) {
      if (param === "Open") {
        return ;
      }
      throw {
            RE_EXN_ID: ParseFailure,
            _1: "expected '('",
            Error: new Error()
          };
    })
};

var right = {
  TAG: /* One */1,
  _0: (function (param) {
      if (param === "Close") {
        return ;
      }
      throw {
            RE_EXN_ID: ParseFailure,
            _1: "expected ')'",
            Error: new Error()
          };
    })
};

function pair(f, g) {
  return {
          TAG: /* Bind */3,
          _0: [
            f,
            (function (x) {
                return {
                        TAG: /* Bind */3,
                        _0: [
                          g,
                          (function (y) {
                              return {
                                      TAG: /* Return */0,
                                      _0: [
                                        x,
                                        y
                                      ]
                                    };
                            })
                        ]
                      };
              })
          ]
        };
}

function triple(f, g, h) {
  return {
          TAG: /* Bind */3,
          _0: [
            f,
            (function (x) {
                return {
                        TAG: /* Bind */3,
                        _0: [
                          g,
                          (function (y) {
                              return {
                                      TAG: /* Bind */3,
                                      _0: [
                                        h,
                                        (function (z) {
                                            return {
                                                    TAG: /* Return */0,
                                                    _0: [
                                                      x,
                                                      y,
                                                      z
                                                    ]
                                                  };
                                          })
                                      ]
                                    };
                            })
                        ]
                      };
              })
          ]
        };
}

function $caret$pipe$pipe(param, p$prime) {
  var p = param[1];
  var name = param[0];
  return {
          TAG: /* Zero */2,
          _0: (function (token) {
              if (typeof token === "string") {
                return p$prime;
              }
              if (token.NAME !== "Atom") {
                return p$prime;
              }
              if (token.VAL !== name) {
                return p$prime;
              }
              var p$prime$1 = Curry._1(p, undefined);
              return {
                      TAG: /* Bind */3,
                      _0: [
                        skip,
                        (function (param) {
                            return p$prime$1;
                          })
                      ]
                    };
            })
        };
}

function map(p, f) {
  return {
          TAG: /* Bind */3,
          _0: [
            p,
            (function (x) {
                return {
                        TAG: /* Return */0,
                        _0: Curry._1(f, x)
                      };
              })
          ]
        };
}

var p_str = {
  TAG: /* One */1,
  _0: (function (param) {
      if (typeof param === "string") {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "expected string",
              Error: new Error()
            };
      }
      if (param.NAME === "Atom") {
        return param.VAL;
      }
      throw {
            RE_EXN_ID: ParseFailure,
            _1: "expected string",
            Error: new Error()
          };
    })
};

var p_int = {
  TAG: /* One */1,
  _0: (function (param) {
      if (typeof param === "string") {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "expected int",
              Error: new Error()
            };
      }
      if (param.NAME === "Atom") {
        try {
          return Caml_format.caml_int_of_string(param.VAL);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Failure") {
            throw {
                  RE_EXN_ID: ParseFailure,
                  _1: "expected int",
                  Error: new Error()
                };
          }
          throw exn;
        }
      } else {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "expected int",
              Error: new Error()
            };
      }
    })
};

var p_bool = {
  TAG: /* One */1,
  _0: (function (param) {
      if (typeof param === "string") {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "expected bool",
              Error: new Error()
            };
      }
      if (param.NAME === "Atom") {
        try {
          return Pervasives.bool_of_string(param.VAL);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Failure") {
            throw {
                  RE_EXN_ID: ParseFailure,
                  _1: "expected bool",
                  Error: new Error()
                };
          }
          throw exn;
        }
      } else {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "expected bool",
              Error: new Error()
            };
      }
    })
};

function many(p) {
  var elements = function (token) {
    if (token === "Close") {
      return {
              TAG: /* Return */0,
              _0: /* [] */0
            };
    } else {
      return {
              TAG: /* Bind */3,
              _0: [
                p,
                (function (x) {
                    var p = {
                      TAG: /* Zero */2,
                      _0: elements
                    };
                    return {
                            TAG: /* Bind */3,
                            _0: [
                              p,
                              (function (l) {
                                  return {
                                          TAG: /* Return */0,
                                          _0: {
                                            hd: x,
                                            tl: l
                                          }
                                        };
                                })
                            ]
                          };
                  })
              ]
            };
    }
  };
  var p$prime = {
    TAG: /* Zero */2,
    _0: elements
  };
  var p$1 = {
    TAG: /* Bind */3,
    _0: [
      left,
      (function (param) {
          return p$prime;
        })
    ]
  };
  return {
          TAG: /* Bind */3,
          _0: [
            p$1,
            (function (l) {
                var p$prime = {
                  TAG: /* Return */0,
                  _0: l
                };
                return {
                        TAG: /* Bind */3,
                        _0: [
                          right,
                          (function (param) {
                              return p$prime;
                            })
                        ]
                      };
              })
          ]
        };
}

function many1(p) {
  return {
          TAG: /* Bind */3,
          _0: [
            p,
            (function (x) {
                var p$1 = many(p);
                return {
                        TAG: /* Bind */3,
                        _0: [
                          p$1,
                          (function (l) {
                              return {
                                      TAG: /* Return */0,
                                      _0: {
                                        hd: x,
                                        tl: l
                                      }
                                    };
                            })
                        ]
                      };
              })
          ]
        };
}

function parse_k(p, tokens, k) {
  var state = {};
  Caml_obj.update_dummy(state, /* Push */{
        _0: [
          p,
          (function (x) {
              var match = Curry._1(k, x);
              if (match === "Stop") {
                return /* Bottom */0;
              } else {
                return state;
              }
            })
        ]
      });
  var one_step = function (_state, token) {
    while(true) {
      var state = _state;
      var match = reduce(state);
      if (match) {
        var match$1 = match._0;
        var f = match$1[0];
        switch (f.TAG | 0) {
          case /* Return */0 :
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "sexpr.re",
                      363,
                      50
                    ],
                    Error: new Error()
                  };
          case /* One */1 :
              var x = Curry._1(f._0, token);
              return reduce(Curry._1(match$1[1], x));
          case /* Zero */2 :
              var p$prime = Curry._1(f._0, token);
              var state$prime = /* Push */{
                _0: [
                  p$prime,
                  match$1[1]
                ]
              };
              _state = state$prime;
              continue ;
          case /* Bind */3 :
              var cont = match$1[1];
              var match$2 = f._0;
              var cont$prime = match$2[1];
              var cont$prime$prime = (function(cont$prime,cont){
              return function cont$prime$prime(x) {
                var p$prime$prime = Curry._1(cont$prime, x);
                return /* Push */{
                        _0: [
                          p$prime$prime,
                          cont
                        ]
                      };
              }
              }(cont$prime,cont));
              var state$prime$1 = /* Push */{
                _0: [
                  match$2[0],
                  cont$prime$prime
                ]
              };
              _state = state$prime$1;
              continue ;
          case /* Fail */4 :
              throw {
                    RE_EXN_ID: ParseFailure,
                    _1: f._0,
                    Error: new Error()
                  };
          
        }
      } else {
        throw {
              RE_EXN_ID: ParseFailure,
              _1: "unexpected ')'",
              Error: new Error()
            };
      }
    };
  };
  var reduce = function (_state) {
    while(true) {
      var state = _state;
      if (!state) {
        return state;
      }
      var match = state._0;
      var x = match[0];
      if (x.TAG !== /* Return */0) {
        return state;
      }
      _state = Curry._1(match[1], x._0);
      continue ;
    };
  };
  Iter$ReasonmlDemoIterators.fold(one_step, state, tokens);
  
}

function parse(p, tokens) {
  var res = {
    contents: undefined
  };
  parse_k(p, tokens, (function (x) {
          res.contents = Caml_option.some(x);
          return "Stop";
        }));
  var x = res.contents;
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: ParseFailure,
        _1: "incomplete input",
        Error: new Error()
      };
}

function parse_seq(p, tokens) {
  return Iter$ReasonmlDemoIterators.from_iter(function (k) {
              return parse_k(p, tokens, (function (x) {
                            Curry._1(k, x);
                            return "Continue";
                          }));
            });
}

exports.iter = iter;
exports.traverse = traverse;
exports.validate = validate;
exports.lex = lex;
exports.of_seq = of_seq;
exports.pp_token = pp_token;
exports.pp_tokens = pp_tokens;
exports.pp_sexpr = pp_sexpr;
exports.output_seq = output_seq;
exports.output_str = output_str;
exports.ParseFailure = ParseFailure;
exports.$great$great$eq = $great$great$eq;
exports.$great$great = $great$great;
exports.$$return = $$return;
exports.fail = fail;
exports.one = one;
exports.skip = skip;
exports.lookahead = lookahead;
exports.left = left;
exports.right = right;
exports.pair = pair;
exports.triple = triple;
exports.$caret$pipe$pipe = $caret$pipe$pipe;
exports.map = map;
exports.p_str = p_str;
exports.p_int = p_int;
exports.p_bool = p_bool;
exports.many = many;
exports.many1 = many1;
exports.parse = parse;
exports.parse_seq = parse_seq;
/* Format Not a pure module */
