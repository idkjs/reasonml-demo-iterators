// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Stack = require("bs-platform/lib/js/stack.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Random = require("bs-platform/lib/js/random.js");
var Stream = require("bs-platform/lib/js/stream.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function from_iter(f) {
  return f;
}

function from_fun(f, k) {
  while(true) {
    var x = Curry._1(f, undefined);
    if (x === undefined) {
      return ;
    }
    Curry._1(k, Caml_option.valFromOption(x));
    continue ;
  };
}

function empty(param) {
  
}

function singleton(x, k) {
  return Curry._1(k, x);
}

function $$return(x, k) {
  return Curry._1(k, x);
}

function pure(f, k) {
  return Curry._1(k, f);
}

function doubleton(x, y, k) {
  Curry._1(k, x);
  return Curry._1(k, y);
}

function cons(x, l, k) {
  Curry._1(k, x);
  return Curry._1(l, k);
}

function snoc(l, x, k) {
  Curry._1(l, k);
  return Curry._1(k, x);
}

function repeat(x, k) {
  while(true) {
    Curry._1(k, x);
  };
  
}

function init(f, $$yield) {
  var _i = 0;
  while(true) {
    var i = _i;
    Curry._1($$yield, Curry._1(f, i));
    _i = i + 1 | 0;
    continue ;
  };
}

function iterate(f, _x, k) {
  while(true) {
    var x = _x;
    Curry._1(k, x);
    _x = Curry._1(f, x);
    continue ;
  };
}

function forever(f, k) {
  while(true) {
    Curry._1(k, Curry._1(f, undefined));
    continue ;
  };
}

function cycle(s, k) {
  while(true) {
    Curry._1(s, k);
  };
  
}

function iter(f, seq) {
  return Curry._1(seq, f);
}

function iteri(f, seq) {
  var r = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                Curry._2(f, r.contents, x);
                r.contents = r.contents + 1 | 0;
                
              }));
}

function fold(f, init, seq) {
  var r = {
    contents: init
  };
  Curry._1(seq, (function (elt) {
          r.contents = Curry._2(f, r.contents, elt);
          
        }));
  return r.contents;
}

function foldi(f, init, seq) {
  var i = {
    contents: 0
  };
  var r = {
    contents: init
  };
  Curry._1(seq, (function (elt) {
          r.contents = Curry._3(f, r.contents, i.contents, elt);
          i.contents = i.contents + 1 | 0;
          
        }));
  return r.contents;
}

function fold_map(f, init, seq, $$yield) {
  var r = {
    contents: init
  };
  return Curry._1(seq, (function (x) {
                var match = Curry._2(f, r.contents, x);
                r.contents = match[0];
                return Curry._1($$yield, match[1]);
              }));
}

function fold_filter_map(f, init, seq, $$yield) {
  var r = {
    contents: init
  };
  return Curry._1(seq, (function (x) {
                var match = Curry._2(f, r.contents, x);
                var y = match[1];
                r.contents = match[0];
                if (y !== undefined) {
                  return Curry._1($$yield, Caml_option.valFromOption(y));
                }
                
              }));
}

function map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._1(k, Curry._1(f, x));
              }));
}

function mapi(f, seq, k) {
  var i = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                Curry._1(k, Curry._2(f, i.contents, x));
                i.contents = i.contents + 1 | 0;
                
              }));
}

function map_by_2(f, seq, k) {
  var r = {
    contents: undefined
  };
  var f$1 = function (y) {
    var x = r.contents;
    if (x !== undefined) {
      return Curry._1(k, Curry._2(f, Caml_option.valFromOption(x), y));
    } else {
      r.contents = Caml_option.some(y);
      return ;
    }
  };
  Curry._1(seq, f$1);
  var x = r.contents;
  if (x !== undefined) {
    return Curry._1(k, Caml_option.valFromOption(x));
  }
  
}

function filter(p, seq, k) {
  return Curry._1(seq, (function (x) {
                if (Curry._1(p, x)) {
                  return Curry._1(k, x);
                }
                
              }));
}

function append(s1, s2, k) {
  Curry._1(s1, k);
  return Curry._1(s2, k);
}

function append_l(l, k) {
  return List.iter((function (sub) {
                return Curry._1(sub, k);
              }), l);
}

function concat(s, k) {
  return Curry._1(s, (function (s$prime) {
                return Curry._1(s$prime, k);
              }));
}

function flatten(s) {
  return function (param) {
    return Curry._1(s, (function (s$prime) {
                  return Curry._1(s$prime, param);
                }));
  };
}

function flat_map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._2(f, x, k);
              }));
}

function flat_map_l(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return List.iter(k, Curry._1(f, x));
              }));
}

function seq_list_map(f, l, k) {
  if (!l) {
    return Curry._1(k, /* [] */0);
  }
  var tail = l.tl;
  return Curry._2(f, l.hd, (function (x$prime) {
                return seq_list_map(f, tail, (function (tail$prime) {
                              return Curry._1(k, {
                                          hd: x$prime,
                                          tl: tail$prime
                                        });
                            }));
              }));
}

function seq_list(l) {
  return function (param) {
    return seq_list_map((function (x) {
                  return x;
                }), l, param);
  };
}

function filter_map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                var y = Curry._1(f, x);
                if (y !== undefined) {
                  return Curry._1(k, Caml_option.valFromOption(y));
                }
                
              }));
}

function filter_mapi(f, seq, k) {
  var i = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                var j = i.contents;
                i.contents = i.contents + 1 | 0;
                var y = Curry._2(f, j, x);
                if (y !== undefined) {
                  return Curry._1(k, Caml_option.valFromOption(y));
                }
                
              }));
}

function filter_count(f, seq) {
  var i = {
    contents: 0
  };
  Curry._1(seq, (function (x) {
          if (Curry._1(f, x)) {
            i.contents = i.contents + 1 | 0;
            return ;
          }
          
        }));
  return i.contents;
}

function intersperse(elem, seq, k) {
  var first = {
    contents: true
  };
  return Curry._1(seq, (function (x) {
                if (first.contents) {
                  first.contents = false;
                } else {
                  Curry._1(k, elem);
                }
                return Curry._1(k, x);
              }));
}

function keep_some(seq, k) {
  return Curry._1(seq, (function (x) {
                if (x !== undefined) {
                  return Curry._1(k, Caml_option.valFromOption(x));
                }
                
              }));
}

function keep_ok(seq, k) {
  return Curry._1(seq, (function (x) {
                if (x.TAG === /* Ok */0) {
                  return Curry._1(k, x._0);
                }
                
              }));
}

function keep_error(seq, k) {
  return Curry._1(seq, (function (x) {
                if (x.TAG === /* Ok */0) {
                  return ;
                } else {
                  return Curry._1(k, x._0);
                }
              }));
}

function of_seq_with(seq, k) {
  var start = {
    contents: /* Nil */0
  };
  var chunk_size = {
    contents: 8
  };
  var prev = {
    contents: start
  };
  var cur = {
    contents: /* Nil */0
  };
  Curry._1(seq, (function (x) {
          Curry._1(k, x);
          var match = cur.contents;
          if (match) {
            var n = match._1;
            var a = match._0;
            if (n.contents >= a.length) {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Sequence.re",
                      345,
                      8
                    ],
                    Error: new Error()
                  };
            }
            Caml_array.set(a, n.contents, x);
            n.contents = n.contents + 1 | 0;
            if (n.contents === a.length) {
              prev.contents.contents = cur.contents;
              prev.contents = match._2;
              cur.contents = /* Nil */0;
              return ;
            } else {
              return ;
            }
          }
          var n$1 = chunk_size.contents;
          if (n$1 < 4096) {
            chunk_size.contents = (chunk_size.contents << 1);
          }
          cur.contents = /* Cons */{
            _0: Caml_array.caml_make_vect(n$1, x),
            _1: {
              contents: 1
            },
            _2: {
              contents: /* Nil */0
            }
          };
          
        }));
  prev.contents.contents = cur.contents;
  return start.contents;
}

function iter$1(f, _l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var a = l._0;
    for(var i = 0 ,i_finish = l._1.contents; i < i_finish; ++i){
      Curry._1(f, Caml_array.get(a, i));
    }
    _l = l._2.contents;
    continue ;
  };
}

function iteri$1(f, l) {
  var _i = 0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var i = _i;
    if (!l$1) {
      return ;
    }
    var n = l$1._1;
    var a = l$1._0;
    for(var j = 0 ,j_finish = n.contents; j < j_finish; ++j){
      Curry._2(f, i + j | 0, Caml_array.get(a, j));
    }
    _l = l$1._2.contents;
    _i = i + n.contents | 0;
    continue ;
  };
}

function iter_rev(f, l) {
  if (!l) {
    return ;
  }
  var a = l._0;
  iter_rev(f, l._2.contents);
  for(var i = l._1.contents - 1 | 0; i >= 0; --i){
    Curry._1(f, Caml_array.get(a, i));
  }
  
}

function length(l) {
  var _acc = 0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (!l$1) {
      return acc;
    }
    _l = l$1._2.contents;
    _acc = acc + l$1._1.contents | 0;
    continue ;
  };
}

function get(_l, _i) {
  while(true) {
    var i = _i;
    var l = _l;
    if (l) {
      var n = l._1;
      if (i < n.contents) {
        return Caml_array.get(l._0, i);
      }
      _i = i - n.contents | 0;
      _l = l._2.contents;
      continue ;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "MList.get",
          Error: new Error()
        };
  };
}

function _to_next(arg, l) {
  var cur = {
    contents: l
  };
  var i = {
    contents: 0
  };
  var get_next = function (_param) {
    while(true) {
      var match = cur.contents;
      if (!match) {
        return ;
      }
      if (i.contents === match._1.contents) {
        cur.contents = match._2.contents;
        i.contents = 0;
        _param = arg;
        continue ;
      }
      var x = Caml_array.get(match._0, i.contents);
      i.contents = i.contents + 1 | 0;
      return Caml_option.some(x);
    };
  };
  return get_next;
}

function persistent(seq) {
  var partial_arg = of_seq_with(seq, (function (param) {
          
        }));
  return function (param) {
    return iter$1(param, partial_arg);
  };
}

function persistent_lazy(seq) {
  var r = {
    contents: /* LazySuspend */0
  };
  return function (k) {
    var seq$prime = r.contents;
    if (seq$prime) {
      return Curry._1(seq$prime._0, k);
    }
    var seq$prime$1 = of_seq_with(seq, k);
    r.contents = /* LazyCached */{
      _0: (function (param) {
          return iter$1(param, seq$prime$1);
        })
    };
    
  };
}

function sort(cmpOpt, seq) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var l = fold((function (l, x) {
          return {
                  hd: x,
                  tl: l
                };
        }), /* [] */0, seq);
  var l$1 = List.fast_sort(cmp, l);
  return function (k) {
    return List.iter(k, l$1);
  };
}

var Exit_sorted = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.Exit_sorted");

function sorted(cmpOpt, seq) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var prev = {
    contents: undefined
  };
  try {
    Curry._1(seq, (function (x) {
            var y = prev.contents;
            if (y === undefined) {
              prev.contents = Caml_option.some(x);
              return ;
            }
            if (Curry._2(cmp, Caml_option.valFromOption(y), x) > 0) {
              throw {
                    RE_EXN_ID: Exit_sorted,
                    Error: new Error()
                  };
            }
            prev.contents = Caml_option.some(x);
            
          }));
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Exit_sorted) {
      return false;
    }
    throw exn;
  }
}

function group_succ_by(eqOpt, seq, k) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var cur = {
    contents: /* [] */0
  };
  Curry._1(seq, (function (x) {
          var l = cur.contents;
          if (l) {
            if (Curry._2(eq, x, l.hd)) {
              cur.contents = {
                hd: x,
                tl: l
              };
            } else {
              Curry._1(k, l);
              cur.contents = {
                hd: x,
                tl: /* [] */0
              };
            }
          } else {
            cur.contents = {
              hd: x,
              tl: /* [] */0
            };
          }
          
        }));
  var l = cur.contents;
  if (l) {
    return Curry._1(k, l);
  }
  
}

function group_by(hashOpt, eqOpt, seq) {
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = {
    LAZY_DONE: false,
    VAL: (function () {
        var tbl = Curry._1(Tbl.create, 32);
        Curry._1(seq, (function (x) {
                var l;
                try {
                  l = Curry._2(Tbl.find, tbl, x);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    l = /* [] */0;
                  } else {
                    throw exn;
                  }
                }
                return Curry._3(Tbl.replace, tbl, x, {
                            hd: x,
                            tl: l
                          });
              }));
        return tbl;
      })
  };
  return function ($$yield) {
    return Curry._2(Tbl.iter, (function (param, l) {
                  return Curry._1($$yield, l);
                }), CamlinternalLazy.force(tbl));
  };
}

function count(hashOpt, eqOpt, seq) {
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = {
    LAZY_DONE: false,
    VAL: (function () {
        var tbl = Curry._1(Tbl.create, 32);
        Curry._1(seq, (function (x) {
                var n;
                try {
                  n = Curry._2(Tbl.find, tbl, x);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    n = 0;
                  } else {
                    throw exn;
                  }
                }
                return Curry._3(Tbl.replace, tbl, x, n + 1 | 0);
              }));
        return tbl;
      })
  };
  return function ($$yield) {
    return Curry._2(Tbl.iter, (function (x, n) {
                  return Curry._1($$yield, [
                              x,
                              n
                            ]);
                }), CamlinternalLazy.force(tbl));
  };
}

function uniq(eqOpt, seq, k) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var has_prev = {
    contents: false
  };
  var prev = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                if (has_prev.contents && Curry._2(eq, prev.contents, x)) {
                  return ;
                } else {
                  has_prev.contents = true;
                  prev.contents = x;
                  return Curry._1(k, x);
                }
              }));
}

function sort_uniq(cmpOpt, seq) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var S = $$Set.Make({
        compare: cmp
      });
  var set = fold((function (acc, x) {
          return Curry._2(S.add, x, acc);
        }), S.empty, seq);
  return function (k) {
    return Curry._2(S.iter, k, set);
  };
}

function product(outer, inner, k) {
  return Curry._1(outer, (function (x) {
                return Curry._1(inner, (function (y) {
                              return Curry._1(k, [
                                          x,
                                          y
                                        ]);
                            }));
              }));
}

function diagonal_l(_l, $$yield) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var tail = l.tl;
    var x = l.hd;
    List.iter((function(x){
        return function (y) {
          return Curry._1($$yield, [
                      x,
                      y
                    ]);
        }
        }(x)), tail);
    _l = tail;
    continue ;
  };
}

function diagonal(seq) {
  var l = {
    contents: /* [] */0
  };
  Curry._1(seq, (function (x) {
          l.contents = {
            hd: x,
            tl: l.contents
          };
          
        }));
  var partial_arg = List.rev(l.contents);
  return function (param) {
    return diagonal_l(partial_arg, param);
  };
}

function join(join_row, s1, s2, k) {
  return Curry._1(s1, (function (a) {
                return Curry._1(s2, (function (b) {
                              var c = Curry._2(join_row, a, b);
                              if (c !== undefined) {
                                return Curry._1(k, Caml_option.valFromOption(c));
                              }
                              
                            }));
              }));
}

function join_by(eqOpt, hashOpt, f1, f2, merge, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c1, (function (x) {
          var key = Curry._1(f1, x);
          return Curry._3(Tbl.add, tbl, key, x);
        }));
  var res = {
    contents: /* [] */0
  };
  Curry._1(c2, (function (y) {
          var key = Curry._1(f2, y);
          var xs = Curry._2(Tbl.find_all, tbl, key);
          return List.iter((function (x) {
                        var z = Curry._3(merge, key, x, y);
                        if (z !== undefined) {
                          res.contents = {
                            hd: Caml_option.valFromOption(z),
                            tl: res.contents
                          };
                          return ;
                        }
                        
                      }), xs);
        }));
  return function ($$yield) {
    return List.iter($$yield, res.contents);
  };
}

function join_all_by(eqOpt, hashOpt, f1, f2, merge, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c1, (function (x) {
          var key = Curry._1(f1, x);
          try {
            var c = Curry._2(Tbl.find, tbl, key);
            c.ja_left = {
              hd: x,
              tl: c.ja_left
            };
            return ;
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              return Curry._3(Tbl.add, tbl, key, {
                          ja_left: {
                            hd: x,
                            tl: /* [] */0
                          },
                          ja_right: /* [] */0
                        });
            }
            throw exn;
          }
        }));
  Curry._1(c2, (function (y) {
          var key = Curry._1(f2, y);
          try {
            var c = Curry._2(Tbl.find, tbl, key);
            c.ja_right = {
              hd: y,
              tl: c.ja_right
            };
            return ;
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              return Curry._3(Tbl.add, tbl, key, {
                          ja_left: /* [] */0,
                          ja_right: {
                            hd: y,
                            tl: /* [] */0
                          }
                        });
            }
            throw exn;
          }
        }));
  var res = {
    contents: /* [] */0
  };
  Curry._2(Tbl.iter, (function (key, cell) {
          var z = Curry._3(merge, key, cell.ja_left, cell.ja_right);
          if (z !== undefined) {
            res.contents = {
              hd: Caml_option.valFromOption(z),
              tl: res.contents
            };
            return ;
          }
          
        }), tbl);
  return function ($$yield) {
    return List.iter($$yield, res.contents);
  };
}

function group_join_by(eqOpt, hashOpt, f, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, /* [] */0);
        }));
  Curry._1(c2, (function (y) {
          var key = Curry._1(f, y);
          try {
            var l = Curry._2(Tbl.find, tbl, key);
            return Curry._3(Tbl.replace, tbl, key, {
                        hd: y,
                        tl: l
                      });
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              return ;
            }
            throw exn;
          }
        }));
  return function ($$yield) {
    return Curry._2(Tbl.iter, (function (k, l) {
                  return Curry._1($$yield, [
                              k,
                              l
                            ]);
                }), tbl);
  };
}

function union(eqOpt, hashOpt, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, undefined);
        }));
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, undefined);
        }));
  return function ($$yield) {
    return Curry._2(Tbl.iter, (function (x, param) {
                  return Curry._1($$yield, x);
                }), tbl);
  };
}

function inter(eqOpt, hashOpt, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, /* Inter_left */0);
        }));
  Curry._1(c2, (function (x) {
          try {
            var match = Curry._2(Tbl.find, tbl, x);
            if (match) {
              return ;
            } else {
              return Curry._3(Tbl.replace, tbl, x, /* Inter_both */1);
            }
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              return ;
            }
            throw exn;
          }
        }));
  return function ($$yield) {
    return Curry._2(Tbl.iter, (function (x, res) {
                  if (res === /* Inter_both */1) {
                    return Curry._1($$yield, x);
                  }
                  
                }), tbl);
  };
}

function diff(eqOpt, hashOpt, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, undefined);
        }));
  return function ($$yield) {
    return Curry._1(c1, (function (x) {
                  if (!Curry._2(Tbl.mem, tbl, x)) {
                    return Curry._1($$yield, x);
                  }
                  
                }));
  };
}

var Subset_exit = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.Subset_exit");

function subset(eqOpt, hashOpt, c1, c2) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var hash = hashOpt !== undefined ? hashOpt : Hashtbl.hash;
  var Tbl = Hashtbl.Make({
        equal: eq,
        hash: hash
      });
  var tbl = Curry._1(Tbl.create, 32);
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl.replace, tbl, x, undefined);
        }));
  try {
    Curry._1(c1, (function (x) {
            if (Curry._2(Tbl.mem, tbl, x)) {
              return ;
            }
            throw {
                  RE_EXN_ID: Subset_exit,
                  Error: new Error()
                };
          }));
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Subset_exit) {
      return false;
    }
    throw exn;
  }
}

function unfoldr(f, _b, k) {
  while(true) {
    var b = _b;
    var match = Curry._1(f, b);
    if (match === undefined) {
      return ;
    }
    Curry._1(k, match[0]);
    _b = match[1];
    continue ;
  };
}

function scan(f, acc, seq, k) {
  Curry._1(k, acc);
  var acc$1 = {
    contents: acc
  };
  return Curry._1(seq, (function (elt) {
                var acc$prime = Curry._2(f, acc$1.contents, elt);
                Curry._1(k, acc$prime);
                acc$1.contents = acc$prime;
                
              }));
}

function max(ltOpt, seq) {
  var lt = ltOpt !== undefined ? ltOpt : Caml_obj.caml_lessthan;
  var ret = {
    contents: undefined
  };
  Curry._1(seq, (function (x) {
          var y = ret.contents;
          if (y !== undefined && !Curry._2(lt, Caml_option.valFromOption(y), x)) {
            return ;
          } else {
            ret.contents = Caml_option.some(x);
            return ;
          }
        }));
  return ret.contents;
}

function max_exn(lt, seq) {
  var x = max(lt, seq);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function min(ltOpt, seq) {
  var lt = ltOpt !== undefined ? ltOpt : Caml_obj.caml_lessthan;
  var ret = {
    contents: undefined
  };
  Curry._1(seq, (function (x) {
          var y = ret.contents;
          if (y !== undefined && !Curry._2(lt, x, Caml_option.valFromOption(y))) {
            return ;
          } else {
            ret.contents = Caml_option.some(x);
            return ;
          }
        }));
  return ret.contents;
}

function min_exn(lt, seq) {
  var x = min(lt, seq);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function sum(seq) {
  var n = {
    contents: 0
  };
  Curry._1(seq, (function (x) {
          n.contents = n.contents + x | 0;
          
        }));
  return n.contents;
}

function sumf(seq) {
  var sum = {
    contents: 0
  };
  var c = {
    contents: 0
  };
  Curry._1(seq, (function (x) {
          var y = x - c.contents;
          var t = sum.contents + y;
          c.contents = t - sum.contents - y;
          sum.contents = t;
          
        }));
  return sum.contents;
}

var ExitHead = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitHead");

function head(seq) {
  var r = {
    contents: undefined
  };
  try {
    Curry._1(seq, (function (x) {
            r.contents = Caml_option.some(x);
            throw {
                  RE_EXN_ID: ExitHead,
                  Error: new Error()
                };
          }));
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitHead) {
      return r.contents;
    }
    throw exn;
  }
}

function head_exn(seq) {
  var x = head(seq);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Pervasives.invalid_arg("Sequence.head_exn");
  }
}

var ExitTake = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitTake");

function take(n, seq, k) {
  var count = {
    contents: 0
  };
  try {
    return Curry._1(seq, (function (x) {
                  if (count.contents === n) {
                    throw {
                          RE_EXN_ID: ExitTake,
                          Error: new Error()
                        };
                  }
                  count.contents = count.contents + 1 | 0;
                  return Curry._1(k, x);
                }));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitTake) {
      return ;
    }
    throw exn;
  }
}

var ExitTakeWhile = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitTakeWhile");

function take_while(p, seq, k) {
  try {
    return Curry._1(seq, (function (x) {
                  if (Curry._1(p, x)) {
                    return Curry._1(k, x);
                  }
                  throw {
                        RE_EXN_ID: ExitTakeWhile,
                        Error: new Error()
                      };
                }));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitTakeWhile) {
      return ;
    }
    throw exn;
  }
}

var ExitFoldWhile = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitFoldWhile");

function fold_while(f, s, seq) {
  var state = {
    contents: s
  };
  var consume = function (x) {
    var match = Curry._2(f, state.contents, x);
    state.contents = match[0];
    if (match[1] !== "Stop") {
      return ;
    }
    throw {
          RE_EXN_ID: ExitFoldWhile,
          Error: new Error()
        };
  };
  try {
    Curry._1(seq, consume);
    return state.contents;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitFoldWhile) {
      return state.contents;
    }
    throw exn;
  }
}

function drop(n, seq, k) {
  var count = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                if (count.contents >= n) {
                  return Curry._1(k, x);
                } else {
                  count.contents = count.contents + 1 | 0;
                  return ;
                }
              }));
}

function drop_while(p, seq, k) {
  var drop = {
    contents: true
  };
  return Curry._1(seq, (function (x) {
                if (drop.contents) {
                  if (Curry._1(p, x)) {
                    return ;
                  } else {
                    drop.contents = false;
                    return Curry._1(k, x);
                  }
                } else {
                  return Curry._1(k, x);
                }
              }));
}

function rev(seq) {
  var l = of_seq_with(seq, (function (param) {
          
        }));
  return function (k) {
    return iter_rev(k, l);
  };
}

var ExitForall = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitForall");

function for_all(p, seq) {
  try {
    Curry._1(seq, (function (x) {
            if (Curry._1(p, x)) {
              return ;
            }
            throw {
                  RE_EXN_ID: ExitForall,
                  Error: new Error()
                };
          }));
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitForall) {
      return false;
    }
    throw exn;
  }
}

var ExitExists = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitExists");

function exists(p, seq) {
  try {
    Curry._1(seq, (function (x) {
            if (!Curry._1(p, x)) {
              return ;
            }
            throw {
                  RE_EXN_ID: ExitExists,
                  Error: new Error()
                };
          }));
    return false;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitExists) {
      return true;
    }
    throw exn;
  }
}

function mem(eqOpt, x, seq) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  return exists(Curry._1(eq, x), seq);
}

var ExitFind = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitFind");

function find_map(f, seq) {
  var r = {
    contents: undefined
  };
  try {
    Curry._1(seq, (function (x) {
            var res = Curry._1(f, x);
            if (res === undefined) {
              return ;
            }
            r.contents = res;
            throw {
                  RE_EXN_ID: ExitFind,
                  Error: new Error()
                };
          }));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID !== ExitFind) {
      throw exn;
    }
    
  }
  return r.contents;
}

function find_mapi(f, seq) {
  var i = {
    contents: 0
  };
  var r = {
    contents: undefined
  };
  try {
    Curry._1(seq, (function (x) {
            var res = Curry._2(f, i.contents, x);
            if (res === undefined) {
              i.contents = i.contents + 1 | 0;
              return ;
            }
            r.contents = res;
            throw {
                  RE_EXN_ID: ExitFind,
                  Error: new Error()
                };
          }));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID !== ExitFind) {
      throw exn;
    }
    
  }
  return r.contents;
}

function find_pred(f, seq) {
  return find_map((function (x) {
                if (Curry._1(f, x)) {
                  return Caml_option.some(x);
                }
                
              }), seq);
}

function find_pred_exn(f, seq) {
  var x = find_pred(f, seq);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function length$1(seq) {
  var r = {
    contents: 0
  };
  Curry._1(seq, (function (param) {
          r.contents = r.contents + 1 | 0;
          
        }));
  return r.contents;
}

var ExitIsEmpty = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitIsEmpty");

function is_empty(seq) {
  try {
    Curry._1(seq, (function (param) {
            throw {
                  RE_EXN_ID: ExitIsEmpty,
                  Error: new Error()
                };
          }));
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ExitIsEmpty) {
      return false;
    }
    throw exn;
  }
}

function zip_i(seq, k) {
  var r = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                var n = r.contents;
                r.contents = r.contents + 1 | 0;
                return Curry._1(k, [
                            n,
                            x
                          ]);
              }));
}

function fold2(f, acc, seq2) {
  var acc$1 = {
    contents: acc
  };
  Curry._1(seq2, (function (param) {
          acc$1.contents = Curry._3(f, acc$1.contents, param[0], param[1]);
          
        }));
  return acc$1.contents;
}

function iter2(f, seq2) {
  return Curry._1(seq2, (function (param) {
                return Curry._2(f, param[0], param[1]);
              }));
}

function map2(f, seq2, k) {
  return Curry._1(seq2, (function (param) {
                return Curry._1(k, Curry._2(f, param[0], param[1]));
              }));
}

function map2_2(f, g, seq2, k) {
  return Curry._1(seq2, (function (param) {
                var y = param[1];
                var x = param[0];
                return Curry._1(k, [
                            Curry._2(f, x, y),
                            Curry._2(g, x, y)
                          ]);
              }));
}

function to_list(seq) {
  return List.rev(fold((function (y, x) {
                    return {
                            hd: x,
                            tl: y
                          };
                  }), /* [] */0, seq));
}

function to_rev_list(seq) {
  return fold((function (y, x) {
                return {
                        hd: x,
                        tl: y
                      };
              }), /* [] */0, seq);
}

function of_list(l, k) {
  return List.iter(k, l);
}

function on_list(f, l) {
  return to_list(Curry._1(f, (function (param) {
                    return List.iter(param, l);
                  })));
}

function pair_with_idx(seq, k) {
  var r = {
    contents: 0
  };
  return Curry._1(seq, (function (x) {
                var n = r.contents;
                r.contents = r.contents + 1 | 0;
                return Curry._1(k, [
                            n,
                            x
                          ]);
              }));
}

function of_opt(o, k) {
  if (o !== undefined) {
    return Curry._1(k, Caml_option.valFromOption(o));
  }
  
}

function to_array(seq) {
  var l = of_seq_with(seq, (function (param) {
          
        }));
  var n = length(l);
  if (n === 0) {
    return [];
  }
  var a = Caml_array.caml_make_vect(n, get(l, 0));
  iteri$1((function (i, x) {
          return Caml_array.set(a, i, x);
        }), l);
  return a;
}

function of_array(a, k) {
  return $$Array.iter(k, a);
}

function of_array_i(a, k) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(k, [
          i,
          a[i]
        ]);
  }
  
}

function array_slice(a, i, j, k) {
  if (!(i >= 0 && j < a.length)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Sequence.re",
            1358,
            2
          ],
          Error: new Error()
        };
  }
  for(var idx = i; idx <= j; ++idx){
    Curry._1(k, Caml_array.get(a, idx));
  }
  
}

function of_stream(s, k) {
  return Stream.iter(k, s);
}

function to_stream(seq) {
  var l = of_seq_with(seq, (function (param) {
          
        }));
  return Stream.from(_to_next(42, l));
}

function to_stack(s, seq) {
  return Curry._1(seq, (function (x) {
                return Stack.push(x, s);
              }));
}

function of_stack(s, k) {
  return Stack.iter(k, s);
}

function to_queue(q, seq) {
  return Curry._1(seq, (function (x) {
                return Queue.push(x, q);
              }));
}

function of_queue(q, k) {
  return Queue.iter(k, q);
}

function hashtbl_add(h, seq) {
  return Curry._1(seq, (function (param) {
                return Hashtbl.add(h, param[0], param[1]);
              }));
}

function hashtbl_replace(h, seq) {
  return Curry._1(seq, (function (param) {
                return Hashtbl.replace(h, param[0], param[1]);
              }));
}

function to_hashtbl(seq) {
  var h = Hashtbl.create(undefined, 3);
  hashtbl_replace(h, seq);
  return h;
}

function of_hashtbl(h, k) {
  return Hashtbl.iter((function (a, b) {
                return Curry._1(k, [
                            a,
                            b
                          ]);
              }), h);
}

function hashtbl_keys(h, k) {
  return Hashtbl.iter((function (a, param) {
                return Curry._1(k, a);
              }), h);
}

function hashtbl_values(h, k) {
  return Hashtbl.iter((function (param, b) {
                return Curry._1(k, b);
              }), h);
}

function of_str(s, k) {
  return $$String.iter(k, s);
}

function to_str(seq) {
  var b = $$Buffer.create(64);
  Curry._1(seq, (function (c) {
          return $$Buffer.add_char(b, c);
        }));
  return $$Buffer.contents(b);
}

function concat_str(seq) {
  var b = $$Buffer.create(64);
  Curry._1(seq, (function (param) {
          return $$Buffer.add_string(b, param);
        }));
  return $$Buffer.contents(b);
}

var OneShotSequence = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.OneShotSequence");

function of_in_channel(ic) {
  var first = {
    contents: true
  };
  return function (k) {
    if (!first.contents) {
      throw {
            RE_EXN_ID: OneShotSequence,
            Error: new Error()
          };
    }
    first.contents = false;
    try {
      while(true) {
        Curry._1(k, Pervasives.input_char(ic));
      };
      return ;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "End_of_file") {
        return ;
      }
      throw exn;
    }
  };
}

function to_buffer(seq, buf) {
  return Curry._1(seq, (function (c) {
                return $$Buffer.add_char(buf, c);
              }));
}

function int_range(start, stop, k) {
  for(var i = start; i <= stop; ++i){
    Curry._1(k, i);
  }
  
}

function int_range_dec(start, stop, k) {
  for(var i = start; i >= stop; --i){
    Curry._1(k, i);
  }
  
}

function int_range_by(step, i, j, $$yield) {
  if (step === 0) {
    Pervasives.invalid_arg("int_range_by");
  }
  for(var k = 0 ,k_finish = Caml_int32.div(j - i | 0, step); k <= k_finish; ++k){
    Curry._1($$yield, Math.imul(k, step) + i | 0);
  }
  
}

function bools(k) {
  Curry._1(k, false);
  return Curry._1(k, true);
}

function of_set(m, set) {
  return function (k) {
    return Curry._2(m.iter, k, set);
  };
}

function to_set(m, seq) {
  return fold((function (set, x) {
                return Curry._2(m.add, x, set);
              }), m.empty, seq);
}

function of_gen(g) {
  var iter1 = function (k) {
    while(true) {
      var x = Curry._1(g, undefined);
      if (x === undefined) {
        return ;
      }
      Curry._1(k, Caml_option.valFromOption(x));
      continue ;
    };
  };
  var partial_arg = of_seq_with(iter1, (function (param) {
          
        }));
  return function (param) {
    return iter$1(param, partial_arg);
  };
}

function to_gen(seq) {
  return _to_next(undefined, of_seq_with(seq, (function (param) {
                    
                  })));
}

function of_klist(_l, k) {
  while(true) {
    var l = _l;
    var match = Curry._1(l, undefined);
    if (typeof match === "string") {
      return ;
    }
    var match$1 = match.VAL;
    Curry._1(k, match$1[0]);
    _l = match$1[1];
    continue ;
  };
}

function to_klist(seq) {
  var l = of_seq_with(seq, (function (param) {
          
        }));
  var make = function (_param, _param$1) {
    while(true) {
      var param = _param;
      var l = param[0];
      if (!l) {
        return "Nil";
      }
      var i = param[1];
      if (i === l._1.contents) {
        _param$1 = undefined;
        _param = [
          l._2.contents,
          0
        ];
        continue ;
      }
      var partial_arg_1 = i + 1 | 0;
      var partial_arg = [
        l,
        partial_arg_1
      ];
      return {
              NAME: "Cons",
              VAL: [
                Caml_array.get(l._0, i),
                (function(partial_arg){
                return function (param) {
                  return make(partial_arg, param);
                }
                }(partial_arg))
              ]
            };
    };
  };
  var partial_arg = [
    l,
    0
  ];
  return function (param) {
    return make(partial_arg, param);
  };
}

function Adapt(X) {
  var to_seq = function (set, k) {
    return Curry._2(X.iter, k, set);
  };
  var of_seq = function (seq) {
    return fold((function (set, x) {
                  return Curry._2(X.add, x, set);
                }), X.empty, seq);
  };
  var to_list$1 = function (set) {
    return to_list(function (param) {
                return Curry._2(X.iter, param, set);
              });
  };
  var empty = X.empty;
  var add = X.add;
  var of_list = function (l) {
    return List.fold_left((function (set, x) {
                  return Curry._2(add, x, set);
                }), empty, l);
  };
  return {
          empty: empty,
          is_empty: X.is_empty,
          mem: X.mem,
          add: add,
          singleton: X.singleton,
          remove: X.remove,
          union: X.union,
          inter: X.inter,
          diff: X.diff,
          compare: X.compare,
          equal: X.equal,
          subset: X.subset,
          iter: X.iter,
          map: X.map,
          fold: X.fold,
          for_all: X.for_all,
          exists: X.exists,
          filter: X.filter,
          partition: X.partition,
          cardinal: X.cardinal,
          elements: X.elements,
          min_elt: X.min_elt,
          min_elt_opt: X.min_elt_opt,
          max_elt: X.max_elt,
          max_elt_opt: X.max_elt_opt,
          choose: X.choose,
          choose_opt: X.choose_opt,
          split: X.split,
          find: X.find,
          find_opt: X.find_opt,
          find_first: X.find_first,
          find_first_opt: X.find_first_opt,
          find_last: X.find_last,
          find_last_opt: X.find_last_opt,
          of_seq: of_seq,
          to_seq: to_seq,
          to_list: to_list$1,
          of_list: of_list
        };
}

function Make(V) {
  var M = $$Map.Make(V);
  var to_seq = function (m) {
    return function (k) {
      return Curry._2(M.iter, (function (x, y) {
                    return Curry._1(k, [
                                x,
                                y
                              ]);
                  }), m);
    };
  };
  var of_seq = function (seq) {
    return fold((function (m, param) {
                  return Curry._3(M.add, param[0], param[1], m);
                }), M.empty, seq);
  };
  var keys = function (m) {
    return function (k) {
      return Curry._2(M.iter, (function (x, param) {
                    return Curry._1(k, x);
                  }), m);
    };
  };
  var values = function (m) {
    return function (k) {
      return Curry._2(M.iter, (function (param, y) {
                    return Curry._1(k, y);
                  }), m);
    };
  };
  var of_list = function (l) {
    return of_seq(function (param) {
                return List.iter(param, l);
              });
  };
  var to_list$1 = function (x) {
    return to_list(to_seq(x));
  };
  return {
          empty: M.empty,
          is_empty: M.is_empty,
          mem: M.mem,
          add: M.add,
          update: M.update,
          singleton: M.singleton,
          remove: M.remove,
          merge: M.merge,
          union: M.union,
          compare: M.compare,
          equal: M.equal,
          iter: M.iter,
          fold: M.fold,
          for_all: M.for_all,
          exists: M.exists,
          filter: M.filter,
          partition: M.partition,
          cardinal: M.cardinal,
          bindings: M.bindings,
          min_binding: M.min_binding,
          min_binding_opt: M.min_binding_opt,
          max_binding: M.max_binding,
          max_binding_opt: M.max_binding_opt,
          choose: M.choose,
          choose_opt: M.choose_opt,
          split: M.split,
          find: M.find,
          find_opt: M.find_opt,
          find_first: M.find_first,
          find_first_opt: M.find_first_opt,
          find_last: M.find_last,
          find_last_opt: M.find_last_opt,
          map: M.map,
          mapi: M.mapi,
          to_seq: to_seq,
          of_seq: of_seq,
          keys: keys,
          values: values,
          to_list: to_list$1,
          of_list: of_list
        };
}

function random_int(bound) {
  return function (param) {
    return forever((function (param) {
                  return Random.$$int(bound);
                }), param);
  };
}

function random_bool(param) {
  return forever(Random.bool, param);
}

function random_float(bound) {
  return function (param) {
    return forever((function (param) {
                  return Random.$$float(bound);
                }), param);
  };
}

function random_array(a, k) {
  if (a.length === 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Sequence.re",
            1622,
            2
          ],
          Error: new Error()
        };
  }
  while(true) {
    var i = Random.$$int(a.length);
    Curry._1(k, Caml_array.get(a, i));
  };
  
}

function random_list(l) {
  var partial_arg = $$Array.of_list(l);
  return function (param) {
    return random_array(partial_arg, param);
  };
}

function shuffle_array(a) {
  for(var k = a.length - 1 | 0; k >= 1; --k){
    var l = Random.$$int(k + 1 | 0);
    var tmp = Caml_array.get(a, l);
    Caml_array.set(a, l, Caml_array.get(a, k));
    Caml_array.set(a, k, tmp);
  }
  
}

function shuffle(seq) {
  var a = to_array(seq);
  shuffle_array(a);
  return function (param) {
    return $$Array.iter(param, a);
  };
}

function shuffle_buffer(n, seq, k) {
  var seq_front = function (param) {
    return take(n, seq, param);
  };
  var a = to_array(seq_front);
  var l = a.length;
  if (l < n) {
    shuffle_array(a);
    return $$Array.iter(k, a);
  } else {
    return drop(n, seq, (function (x) {
                  var i = Random.$$int(n);
                  var y = Caml_array.get(a, i);
                  Caml_array.set(a, i, x);
                  return Curry._1(k, y);
                }));
  }
}

function sample(n, seq) {
  var x = head(seq);
  if (x === undefined) {
    return [];
  }
  var a = Caml_array.caml_make_vect(n, Caml_option.valFromOption(x));
  var i = {
    contents: -1
  };
  var f = function (x) {
    i.contents = i.contents + 1 | 0;
    if (i.contents < n) {
      return Caml_array.set(a, i.contents, x);
    }
    var j = Random.$$int(n);
    if (j <= n) {
      return Caml_array.set(a, i.contents, x);
    }
    
  };
  Curry._1(seq, f);
  if (i.contents < n) {
    return $$Array.sub(a, 0, i.contents);
  } else {
    return a;
  }
}

function $neg$neg(i, j) {
  return function (param) {
    return int_range(i, j, param);
  };
}

function $neg$neg$caret(i, j) {
  return function (param) {
    return int_range_dec(i, j, param);
  };
}

function $great$great$eq(x, f) {
  return function (param) {
    return Curry._1(x, (function (x) {
                  return Curry._2(f, x, param);
                }));
  };
}

function $great$pipe$eq(x, f) {
  return function (param) {
    return Curry._1(x, (function (x) {
                  return Curry._1(param, Curry._1(f, x));
                }));
  };
}

function $less$star$great(funs, args, k) {
  return Curry._1(funs, (function (f) {
                return Curry._1(args, (function (x) {
                              return Curry._1(k, Curry._1(f, x));
                            }));
              }));
}

var Infix = {
  $neg$neg: $neg$neg,
  $neg$neg$caret: $neg$neg$caret,
  $great$great$eq: $great$great$eq,
  $great$pipe$eq: $great$pipe$eq,
  $less$star$great: $less$star$great,
  $less$plus$great: append
};

function pp_seq(sepOpt, pp_elt, formatter, seq) {
  var sep = sepOpt !== undefined ? sepOpt : ", ";
  var first = {
    contents: true
  };
  return Curry._1(seq, (function (x) {
                if (first.contents) {
                  first.contents = false;
                } else {
                  Format.pp_print_string(formatter, sep);
                  Format.pp_print_cut(formatter, undefined);
                }
                return Curry._2(pp_elt, formatter, x);
              }));
}

function pp_buf(sepOpt, pp_elt, buf, seq) {
  var sep = sepOpt !== undefined ? sepOpt : ", ";
  var first = {
    contents: true
  };
  return Curry._1(seq, (function (x) {
                if (first.contents) {
                  first.contents = false;
                } else {
                  $$Buffer.add_string(buf, sep);
                }
                return Curry._2(pp_elt, buf, x);
              }));
}

function to_string(sep, pp_elt, seq) {
  var buf = $$Buffer.create(25);
  pp_buf(sep, (function (buf, x) {
          return $$Buffer.add_string(buf, Curry._1(pp_elt, x));
        }), buf, seq);
  return $$Buffer.contents(buf);
}

function lines_of(modeOpt, flagsOpt, filename, k) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : ({
        hd: /* Open_rdonly */0,
        tl: /* [] */0
      });
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    while(true) {
      Curry._1(k, Pervasives.input_line(ic));
    };
    return ;
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === "End_of_file") {
      return Pervasives.close_in(ic);
    }
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function chunks_of(modeOpt, flagsOpt, sizeOpt, filename, k) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : /* [] */0;
  var size = sizeOpt !== undefined ? sizeOpt : 1024;
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    var buf = Caml_bytes.caml_create_bytes(size);
    var n = 0;
    var stop = false;
    while(!stop) {
      n = 0;
      while(n < size && !stop) {
        var n$prime = Pervasives.input(ic, buf, n, size - n | 0);
        if (n$prime === 0) {
          stop = true;
        } else {
          n = n + n$prime | 0;
        }
      };
      if (n > 0) {
        Curry._1(k, Bytes.sub_string(buf, 0, n));
      }
      
    };
    return Pervasives.close_in(ic);
  }
  catch (e){
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function write_bytes_to(modeOpt, flagsOpt, filename, seq) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : ({
        hd: /* Open_creat */3,
        tl: {
          hd: /* Open_wronly */1,
          tl: /* [] */0
        }
      });
  var oc = Pervasives.open_out_gen(flags, mode, filename);
  try {
    Curry._1(seq, (function (s) {
            return Pervasives.output(oc, s, 0, s.length);
          }));
    return Pervasives.close_out(oc);
  }
  catch (e){
    Pervasives.close_out(oc);
    throw e;
  }
}

function write_to(mode, flags, filename, seq) {
  return write_bytes_to(mode, flags, filename, (function (param) {
                return Curry._1(seq, (function (x) {
                              return Curry._1(param, Bytes.unsafe_of_string(x));
                            }));
              }));
}

function write_bytes_lines(mode, flags, filename, seq) {
  var ret = Bytes.unsafe_of_string("\n");
  return write_bytes_to(mode, flags, filename, (function (param) {
                intersperse(ret, seq, param);
                return Curry._1(param, ret);
              }));
}

function write_lines(mode, flags, filename, seq) {
  return write_bytes_lines(mode, flags, filename, (function (param) {
                return Curry._1(seq, (function (x) {
                              return Curry._1(param, Bytes.unsafe_of_string(x));
                            }));
              }));
}

var find = find_map;

var findi = find_mapi;

var to_opt = head;

function Set_Make(funarg) {
  var MySet = $$Set.Make(funarg);
  var to_seq = function (set, k) {
    return Curry._2(MySet.iter, k, set);
  };
  var of_seq = function (seq) {
    return fold((function (set, x) {
                  return Curry._2(MySet.add, x, set);
                }), MySet.empty, seq);
  };
  var to_list$1 = function (set) {
    return to_list(function (param) {
                return Curry._2(MySet.iter, param, set);
              });
  };
  var empty = MySet.empty;
  var add = MySet.add;
  var of_list = function (l) {
    return List.fold_left((function (set, x) {
                  return Curry._2(add, x, set);
                }), empty, l);
  };
  return {
          empty: empty,
          is_empty: MySet.is_empty,
          mem: MySet.mem,
          add: add,
          singleton: MySet.singleton,
          remove: MySet.remove,
          union: MySet.union,
          inter: MySet.inter,
          diff: MySet.diff,
          compare: MySet.compare,
          equal: MySet.equal,
          subset: MySet.subset,
          iter: MySet.iter,
          map: MySet.map,
          fold: MySet.fold,
          for_all: MySet.for_all,
          exists: MySet.exists,
          filter: MySet.filter,
          partition: MySet.partition,
          cardinal: MySet.cardinal,
          elements: MySet.elements,
          min_elt: MySet.min_elt,
          min_elt_opt: MySet.min_elt_opt,
          max_elt: MySet.max_elt,
          max_elt_opt: MySet.max_elt_opt,
          choose: MySet.choose,
          choose_opt: MySet.choose_opt,
          split: MySet.split,
          find: MySet.find,
          find_opt: MySet.find_opt,
          find_first: MySet.find_first,
          find_first_opt: MySet.find_first_opt,
          find_last: MySet.find_last,
          find_last_opt: MySet.find_last_opt,
          of_seq: of_seq,
          to_seq: to_seq,
          to_list: to_list$1,
          of_list: of_list
        };
}

var $$Set$1 = {
  Adapt: Adapt,
  Make: Set_Make
};

function Map_Adapt(funarg) {
  var to_seq = function (m) {
    return function (k) {
      return Curry._2(funarg.iter, (function (x, y) {
                    return Curry._1(k, [
                                x,
                                y
                              ]);
                  }), m);
    };
  };
  var of_seq = function (seq) {
    return fold((function (m, param) {
                  return Curry._3(funarg.add, param[0], param[1], m);
                }), funarg.empty, seq);
  };
  var keys = function (m) {
    return function (k) {
      return Curry._2(funarg.iter, (function (x, param) {
                    return Curry._1(k, x);
                  }), m);
    };
  };
  var values = function (m) {
    return function (k) {
      return Curry._2(funarg.iter, (function (param, y) {
                    return Curry._1(k, y);
                  }), m);
    };
  };
  var of_list = function (l) {
    return of_seq(function (param) {
                return List.iter(param, l);
              });
  };
  var to_list$1 = function (x) {
    return to_list(to_seq(x));
  };
  return {
          empty: funarg.empty,
          is_empty: funarg.is_empty,
          mem: funarg.mem,
          add: funarg.add,
          update: funarg.update,
          singleton: funarg.singleton,
          remove: funarg.remove,
          merge: funarg.merge,
          union: funarg.union,
          compare: funarg.compare,
          equal: funarg.equal,
          iter: funarg.iter,
          fold: funarg.fold,
          for_all: funarg.for_all,
          exists: funarg.exists,
          filter: funarg.filter,
          partition: funarg.partition,
          cardinal: funarg.cardinal,
          bindings: funarg.bindings,
          min_binding: funarg.min_binding,
          min_binding_opt: funarg.min_binding_opt,
          max_binding: funarg.max_binding,
          max_binding_opt: funarg.max_binding_opt,
          choose: funarg.choose,
          choose_opt: funarg.choose_opt,
          split: funarg.split,
          find: funarg.find,
          find_opt: funarg.find_opt,
          find_first: funarg.find_first,
          find_first_opt: funarg.find_first_opt,
          find_last: funarg.find_last,
          find_last_opt: funarg.find_last_opt,
          map: funarg.map,
          mapi: funarg.mapi,
          to_seq: to_seq,
          of_seq: of_seq,
          keys: keys,
          values: values,
          to_list: to_list$1,
          of_list: of_list
        };
}

var $$Map$1 = {
  Adapt: Map_Adapt,
  Make: Make
};

var $less$plus$great = append;

var IO = {
  lines_of: lines_of,
  chunks_of: chunks_of,
  write_to: write_to,
  write_bytes_to: write_bytes_to,
  write_lines: write_lines,
  write_bytes_lines: write_bytes_lines
};

exports.from_iter = from_iter;
exports.from_fun = from_fun;
exports.empty = empty;
exports.singleton = singleton;
exports.doubleton = doubleton;
exports.init = init;
exports.cons = cons;
exports.snoc = snoc;
exports.$$return = $$return;
exports.pure = pure;
exports.repeat = repeat;
exports.iterate = iterate;
exports.forever = forever;
exports.cycle = cycle;
exports.iter = iter;
exports.iteri = iteri;
exports.fold = fold;
exports.foldi = foldi;
exports.fold_map = fold_map;
exports.fold_filter_map = fold_filter_map;
exports.map = map;
exports.mapi = mapi;
exports.map_by_2 = map_by_2;
exports.for_all = for_all;
exports.exists = exists;
exports.mem = mem;
exports.find = find;
exports.find_map = find_map;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.find_pred = find_pred;
exports.find_pred_exn = find_pred_exn;
exports.length = length$1;
exports.is_empty = is_empty;
exports.filter = filter;
exports.append = append;
exports.append_l = append_l;
exports.concat = concat;
exports.flatten = flatten;
exports.flat_map = flat_map;
exports.flat_map_l = flat_map_l;
exports.seq_list = seq_list;
exports.seq_list_map = seq_list_map;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter_count = filter_count;
exports.intersperse = intersperse;
exports.keep_some = keep_some;
exports.keep_ok = keep_ok;
exports.keep_error = keep_error;
exports.persistent = persistent;
exports.persistent_lazy = persistent_lazy;
exports.sort = sort;
exports.sort_uniq = sort_uniq;
exports.sorted = sorted;
exports.group_succ_by = group_succ_by;
exports.group_by = group_by;
exports.count = count;
exports.uniq = uniq;
exports.product = product;
exports.diagonal_l = diagonal_l;
exports.diagonal = diagonal;
exports.join = join;
exports.join_by = join_by;
exports.join_all_by = join_all_by;
exports.group_join_by = group_join_by;
exports.inter = inter;
exports.union = union;
exports.diff = diff;
exports.subset = subset;
exports.unfoldr = unfoldr;
exports.scan = scan;
exports.max = max;
exports.max_exn = max_exn;
exports.min = min;
exports.min_exn = min_exn;
exports.sum = sum;
exports.sumf = sumf;
exports.head = head;
exports.head_exn = head_exn;
exports.take = take;
exports.take_while = take_while;
exports.fold_while = fold_while;
exports.drop = drop;
exports.drop_while = drop_while;
exports.rev = rev;
exports.zip_i = zip_i;
exports.fold2 = fold2;
exports.iter2 = iter2;
exports.map2 = map2;
exports.map2_2 = map2_2;
exports.to_list = to_list;
exports.to_rev_list = to_rev_list;
exports.of_list = of_list;
exports.on_list = on_list;
exports.pair_with_idx = pair_with_idx;
exports.to_opt = to_opt;
exports.to_array = to_array;
exports.of_array = of_array;
exports.of_array_i = of_array_i;
exports.array_slice = array_slice;
exports.of_opt = of_opt;
exports.of_stream = of_stream;
exports.to_stream = to_stream;
exports.to_stack = to_stack;
exports.of_stack = of_stack;
exports.to_queue = to_queue;
exports.of_queue = of_queue;
exports.hashtbl_add = hashtbl_add;
exports.hashtbl_replace = hashtbl_replace;
exports.to_hashtbl = to_hashtbl;
exports.of_hashtbl = of_hashtbl;
exports.hashtbl_keys = hashtbl_keys;
exports.hashtbl_values = hashtbl_values;
exports.of_str = of_str;
exports.to_str = to_str;
exports.concat_str = concat_str;
exports.OneShotSequence = OneShotSequence;
exports.of_in_channel = of_in_channel;
exports.to_buffer = to_buffer;
exports.int_range = int_range;
exports.int_range_dec = int_range_dec;
exports.int_range_by = int_range_by;
exports.bools = bools;
exports.of_set = of_set;
exports.to_set = to_set;
exports.of_gen = of_gen;
exports.to_gen = to_gen;
exports.of_klist = of_klist;
exports.to_klist = to_klist;
exports.$$Set = $$Set$1;
exports.$$Map = $$Map$1;
exports.random_int = random_int;
exports.random_bool = random_bool;
exports.random_float = random_float;
exports.random_array = random_array;
exports.random_list = random_list;
exports.shuffle = shuffle;
exports.shuffle_buffer = shuffle_buffer;
exports.sample = sample;
exports.Infix = Infix;
exports.$neg$neg = $neg$neg;
exports.$neg$neg$caret = $neg$neg$caret;
exports.$great$great$eq = $great$great$eq;
exports.$great$pipe$eq = $great$pipe$eq;
exports.$less$star$great = $less$star$great;
exports.$less$plus$great = $less$plus$great;
exports.pp_seq = pp_seq;
exports.pp_buf = pp_buf;
exports.to_string = to_string;
exports.IO = IO;
/* Format Not a pure module */
