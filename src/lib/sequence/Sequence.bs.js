// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map                   = require("bs-platform/lib/js/map.js");
var $$Set                   = require("bs-platform/lib/js/set.js");
var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Bytes                   = require("bs-platform/lib/js/bytes.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Queue                   = require("bs-platform/lib/js/queue.js");
var Stack                   = require("bs-platform/lib/js/stack.js");
var Buffer                  = require("bs-platform/lib/js/buffer.js");
var Format                  = require("bs-platform/lib/js/format.js");
var Random                  = require("bs-platform/lib/js/random.js");
var Stream                  = require("bs-platform/lib/js/stream.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Hashtbl                 = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy        = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function from_iter(f) {
  return f;
}

function from_fun(f, k) {
  while(true) {
    var match = Curry._1(f, /* () */0);
    if (match) {
      Curry._1(k, match[0]);
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function empty() {
  return /* () */0;
}

function singleton(x, k) {
  return Curry._1(k, x);
}

function $$return(x, k) {
  return Curry._1(k, x);
}

function pure(f, k) {
  return Curry._1(k, f);
}

function doubleton(x, y, k) {
  Curry._1(k, x);
  return Curry._1(k, y);
}

function cons(x, l, k) {
  Curry._1(k, x);
  return Curry._1(l, k);
}

function snoc(l, x, k) {
  Curry._1(l, k);
  return Curry._1(k, x);
}

function repeat(x, k) {
  while(true) {
    Curry._1(k, x);
  };
  return /* () */0;
}

function init(f, $$yield) {
  var _i = 0;
  while(true) {
    var i = _i;
    Curry._1($$yield, Curry._1(f, i));
    _i = i + 1 | 0;
    continue ;
    
  };
}

function iterate(f, _x, k) {
  while(true) {
    var x = _x;
    Curry._1(k, x);
    _x = Curry._1(f, x);
    continue ;
    
  };
}

function forever(f, k) {
  while(true) {
    Curry._1(k, Curry._1(f, /* () */0));
    continue ;
    
  };
}

function cycle(s, k) {
  while(true) {
    Curry._1(s, k);
  };
  return /* () */0;
}

function iter(f, seq) {
  return Curry._1(seq, f);
}

function iteri(f, seq) {
  var r = [0];
  return Curry._1(seq, (function (x) {
                Curry._2(f, r[0], x);
                r[0] = r[0] + 1 | 0;
                return /* () */0;
              }));
}

function fold(f, init, seq) {
  var r = [init];
  Curry._1(seq, (function (elt) {
          r[0] = Curry._2(f, r[0], elt);
          return /* () */0;
        }));
  return r[0];
}

function foldi(f, init, seq) {
  var i = [0];
  var r = [init];
  Curry._1(seq, (function (elt) {
          r[0] = Curry._3(f, r[0], i[0], elt);
          i[0] = i[0] + 1 | 0;
          return /* () */0;
        }));
  return r[0];
}

function fold_map(f, init, seq, $$yield) {
  var r = [init];
  return Curry._1(seq, (function (x) {
                var match = Curry._2(f, r[0], x);
                r[0] = match[0];
                return Curry._1($$yield, match[1]);
              }));
}

function fold_filter_map(f, init, seq, $$yield) {
  var r = [init];
  return Curry._1(seq, (function (x) {
                var match = Curry._2(f, r[0], x);
                var y = match[1];
                r[0] = match[0];
                if (y) {
                  return Curry._1($$yield, y[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._1(k, Curry._1(f, x));
              }));
}

function mapi(f, seq, k) {
  var i = [0];
  return Curry._1(seq, (function (x) {
                Curry._1(k, Curry._2(f, i[0], x));
                i[0] = i[0] + 1 | 0;
                return /* () */0;
              }));
}

function map_by_2(f, seq, k) {
  var r = [/* None */0];
  var f$1 = function (y) {
    var match = r[0];
    if (match) {
      return Curry._1(k, Curry._2(f, match[0], y));
    } else {
      r[0] = /* Some */[y];
      return /* () */0;
    }
  };
  Curry._1(seq, f$1);
  var match = r[0];
  if (match) {
    return Curry._1(k, match[0]);
  } else {
    return /* () */0;
  }
}

function filter(p, seq, k) {
  return Curry._1(seq, (function (x) {
                if (Curry._1(p, x)) {
                  return Curry._1(k, x);
                } else {
                  return 0;
                }
              }));
}

function append(s1, s2, k) {
  Curry._1(s1, k);
  return Curry._1(s2, k);
}

function append_l(l, k) {
  return List.iter((function (sub) {
                return Curry._1(sub, k);
              }), l);
}

function concat(s, k) {
  return Curry._1(s, (function (s$prime) {
                return Curry._1(s$prime, k);
              }));
}

function flatten(s) {
  return (function (param) {
      return Curry._1(s, (function (s$prime) {
                    return Curry._1(s$prime, param);
                  }));
    });
}

function flat_map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._2(f, x, k);
              }));
}

function flat_map_l(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return List.iter(k, Curry._1(f, x));
              }));
}

function seq_list_map(f, l, k) {
  if (l) {
    var tail = l[1];
    return Curry._2(f, l[0], (function (x$prime) {
                  return seq_list_map(f, tail, (function (tail$prime) {
                                return Curry._1(k, /* :: */[
                                            x$prime,
                                            tail$prime
                                          ]);
                              }));
                }));
  } else {
    return Curry._1(k, /* [] */0);
  }
}

function seq_list(l) {
  return (function (param) {
      return seq_list_map((function (x) {
                    return x;
                  }), l, param);
    });
}

function filter_map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                var match = Curry._1(f, x);
                if (match) {
                  return Curry._1(k, match[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function filter_mapi(f, seq, k) {
  var i = [0];
  return Curry._1(seq, (function (x) {
                var j = i[0];
                i[0] = i[0] + 1 | 0;
                var match = Curry._2(f, j, x);
                if (match) {
                  return Curry._1(k, match[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function filter_count(f, seq) {
  var i = [0];
  Curry._1(seq, (function (x) {
          if (Curry._1(f, x)) {
            i[0] = i[0] + 1 | 0;
            return /* () */0;
          } else {
            return 0;
          }
        }));
  return i[0];
}

function intersperse(elem, seq, k) {
  var first = [/* true */1];
  return Curry._1(seq, (function (x) {
                if (first[0]) {
                  first[0] = /* false */0;
                } else {
                  Curry._1(k, elem);
                }
                return Curry._1(k, x);
              }));
}

function keep_some(seq, k) {
  return Curry._1(seq, (function (param) {
                if (param) {
                  return Curry._1(k, param[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function keep_ok(seq, k) {
  return Curry._1(seq, (function (param) {
                if (param.tag) {
                  return /* () */0;
                } else {
                  return Curry._1(k, param[0]);
                }
              }));
}

function keep_error(seq, k) {
  return Curry._1(seq, (function (param) {
                if (param.tag) {
                  return Curry._1(k, param[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function of_seq_with(seq, k) {
  var start = [/* Nil */0];
  var chunk_size = [8];
  var match_000 = [start];
  var match_001 = [/* Nil */0];
  var cur = match_001;
  var prev = match_000;
  Curry._1(seq, (function (x) {
          Curry._1(k, x);
          var match = cur[0];
          if (match) {
            var n = match[1];
            var a = match[0];
            if (n[0] >= a.length) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "Sequence.ml",
                      272,
                      11
                    ]
                  ];
            }
            Caml_array.caml_array_set(a, n[0], x);
            n[0] = n[0] + 1 | 0;
            if (n[0] === a.length) {
              prev[0][0] = cur[0];
              prev[0] = match[2];
              cur[0] = /* Nil */0;
              return /* () */0;
            } else {
              return 0;
            }
          } else {
            var n$1 = chunk_size[0];
            if (n$1 < 4096) {
              chunk_size[0] = (chunk_size[0] << 1);
            }
            cur[0] = /* Cons */[
              Caml_array.caml_make_vect(n$1, x),
              [1],
              [/* Nil */0]
            ];
            return /* () */0;
          }
        }));
  prev[0][0] = cur[0];
  return start[0];
}

function iter$1(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var a = l[0];
      for(var i = 0 ,i_finish = l[1][0] - 1 | 0; i <= i_finish; ++i){
        Curry._1(f, Caml_array.caml_array_get(a, i));
      }
      _l = l[2][0];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iteri$1(f, l) {
  var _i = 0;
  var f$1 = f;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var i = _i;
    if (l$1) {
      var n = l$1[1];
      var a = l$1[0];
      for(var j = 0 ,j_finish = n[0] - 1 | 0; j <= j_finish; ++j){
        Curry._2(f$1, i + j | 0, Caml_array.caml_array_get(a, j));
      }
      _l = l$1[2][0];
      _i = i + n[0] | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iter_rev(f, l) {
  if (l) {
    var a = l[0];
    iter_rev(f, l[2][0]);
    for(var i = l[1][0] - 1 | 0; i >= 0; --i){
      Curry._1(f, Caml_array.caml_array_get(a, i));
    }
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function length(l) {
  var _acc = 0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      _l = l$1[2][0];
      _acc = acc + l$1[1][0] | 0;
      continue ;
      
    } else {
      return acc;
    }
  };
}

function get(_l, _i) {
  while(true) {
    var i = _i;
    var l = _l;
    if (l) {
      var n = l[1];
      if (i < n[0]) {
        return Caml_array.caml_array_get(l[0], i);
      } else {
        _i = i - n[0] | 0;
        _l = l[2][0];
        continue ;
        
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "MList.get"
          ];
    }
  };
}

function _to_next(arg, l) {
  var cur = [l];
  var i = [0];
  var get_next = function (_param) {
    while(true) {
      var match = cur[0];
      if (match) {
        if (i[0] === match[1][0]) {
          cur[0] = match[2][0];
          i[0] = 0;
          _param = arg;
          continue ;
          
        } else {
          var x = Caml_array.caml_array_get(match[0], i[0]);
          i[0] = i[0] + 1 | 0;
          return /* Some */[x];
        }
      } else {
        return /* None */0;
      }
    };
  };
  return get_next;
}

function persistent(seq) {
  var partial_arg = of_seq_with(seq, (function () {
          return /* () */0;
        }));
  return (function (param) {
      return iter$1(param, partial_arg);
    });
}

function persistent_lazy(seq) {
  var r = [/* LazySuspend */0];
  return (function (k) {
      var match = r[0];
      if (match) {
        return Curry._1(match[0], k);
      } else {
        var seq$prime = of_seq_with(seq, k);
        r[0] = /* LazyCached */[(function (param) {
              return iter$1(param, seq$prime);
            })];
        return /* () */0;
      }
    });
}

function sort($staropt$star, seq) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var l = fold((function (l, x) {
          return /* :: */[
                  x,
                  l
                ];
        }), /* [] */0, seq);
  var l$1 = List.fast_sort(cmp, l);
  return (function (k) {
      return List.iter(k, l$1);
    });
}

var Exit_sorted = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.Exit_sorted");

function sorted($staropt$star, seq) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var prev = [/* None */0];
  try {
    Curry._1(seq, (function (x) {
            var match = prev[0];
            if (match) {
              if (Curry._2(cmp, match[0], x) > 0) {
                throw Exit_sorted;
              } else {
                prev[0] = /* Some */[x];
                return /* () */0;
              }
            } else {
              prev[0] = /* Some */[x];
              return /* () */0;
            }
          }));
    return /* true */1;
  }
  catch (exn){
    if (exn === Exit_sorted) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function group_succ_by($staropt$star, seq, k) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var cur = [/* [] */0];
  Curry._1(seq, (function (x) {
          var l = cur[0];
          if (l) {
            if (Curry._2(eq, x, l[0])) {
              cur[0] = /* :: */[
                x,
                l
              ];
              return /* () */0;
            } else {
              Curry._1(k, l);
              cur[0] = /* :: */[
                x,
                /* [] */0
              ];
              return /* () */0;
            }
          } else {
            cur[0] = /* :: */[
              x,
              /* [] */0
            ];
            return /* () */0;
          }
        }));
  var l = cur[0];
  if (l) {
    return Curry._1(k, l);
  } else {
    return /* () */0;
  }
}

function group_by($staropt$star, $staropt$star$1, seq) {
  var hash = $staropt$star ? $staropt$star[0] : Hashtbl.hash;
  var eq = $staropt$star$1 ? $staropt$star$1[0] : Caml_obj.caml_equal;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Block.__(246, [(function () {
          var tbl = Curry._1(Tbl[/* create */0], 32);
          Curry._1(seq, (function (x) {
                  var l;
                  try {
                    l = Curry._2(Tbl[/* find */6], tbl, x);
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      l = /* [] */0;
                    } else {
                      throw exn;
                    }
                  }
                  return Curry._3(Tbl[/* replace */8], tbl, x, /* :: */[
                              x,
                              l
                            ]);
                }));
          return tbl;
        })]);
  return (function ($$yield) {
      var tag = tbl.tag | 0;
      return Curry._2(Tbl[/* iter */10], (function (_, l) {
                    return Curry._1($$yield, l);
                  }), tag === 250 ? tbl[0] : (
                    tag === 246 ? CamlinternalLazy.force_lazy_block(tbl) : tbl
                  ));
    });
}

function count($staropt$star, $staropt$star$1, seq) {
  var hash = $staropt$star ? $staropt$star[0] : Hashtbl.hash;
  var eq = $staropt$star$1 ? $staropt$star$1[0] : Caml_obj.caml_equal;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Block.__(246, [(function () {
          var tbl = Curry._1(Tbl[/* create */0], 32);
          Curry._1(seq, (function (x) {
                  var n;
                  try {
                    n = Curry._2(Tbl[/* find */6], tbl, x);
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      n = 0;
                    } else {
                      throw exn;
                    }
                  }
                  return Curry._3(Tbl[/* replace */8], tbl, x, n + 1 | 0);
                }));
          return tbl;
        })]);
  return (function ($$yield) {
      var tag = tbl.tag | 0;
      return Curry._2(Tbl[/* iter */10], (function (x, n) {
                    return Curry._1($$yield, /* tuple */[
                                x,
                                n
                              ]);
                  }), tag === 250 ? tbl[0] : (
                    tag === 246 ? CamlinternalLazy.force_lazy_block(tbl) : tbl
                  ));
    });
}

function uniq($staropt$star, seq, k) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var has_prev = [/* false */0];
  var prev = [0];
  return Curry._1(seq, (function (x) {
                if (has_prev[0] && Curry._2(eq, prev[0], x)) {
                  return /* () */0;
                } else {
                  has_prev[0] = /* true */1;
                  prev[0] = x;
                  return Curry._1(k, x);
                }
              }));
}

function sort_uniq($staropt$star, seq) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var S = $$Set.Make(/* module */[/* compare */cmp]);
  var set = fold((function (acc, x) {
          return Curry._2(S[/* add */3], x, acc);
        }), S[/* empty */0], seq);
  return (function (k) {
      return Curry._2(S[/* iter */12], k, set);
    });
}

function product(outer, inner, k) {
  return Curry._1(outer, (function (x) {
                return Curry._1(inner, (function (y) {
                              return Curry._1(k, /* tuple */[
                                          x,
                                          y
                                        ]);
                            }));
              }));
}

function diagonal_l(_l, $$yield) {
  while(true) {
    var l = _l;
    if (l) {
      var tail = l[1];
      var x = l[0];
      List.iter((function(x){
          return function (y) {
            return Curry._1($$yield, /* tuple */[
                        x,
                        y
                      ]);
          }
          }(x)), tail);
      _l = tail;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function diagonal(seq) {
  var l = [/* [] */0];
  Curry._1(seq, (function (x) {
          l[0] = /* :: */[
            x,
            l[0]
          ];
          return /* () */0;
        }));
  var partial_arg = List.rev(l[0]);
  return (function (param) {
      return diagonal_l(partial_arg, param);
    });
}

function join(join_row, s1, s2, k) {
  return Curry._1(s1, (function (a) {
                return Curry._1(s2, (function (b) {
                              var match = Curry._2(join_row, a, b);
                              if (match) {
                                return Curry._1(k, match[0]);
                              } else {
                                return /* () */0;
                              }
                            }));
              }));
}

function join_by($staropt$star, $staropt$star$1, f1, f2, merge, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c1, (function (x) {
          var key = Curry._1(f1, x);
          return Curry._3(Tbl[/* add */4], tbl, key, x);
        }));
  var res = [/* [] */0];
  Curry._1(c2, (function (y) {
          var key = Curry._1(f2, y);
          var xs = Curry._2(Tbl[/* find_all */7], tbl, key);
          return List.iter((function (x) {
                        var match = Curry._3(merge, key, x, y);
                        if (match) {
                          res[0] = /* :: */[
                            match[0],
                            res[0]
                          ];
                          return /* () */0;
                        } else {
                          return /* () */0;
                        }
                      }), xs);
        }));
  return (function ($$yield) {
      return List.iter($$yield, res[0]);
    });
}

function join_all_by($staropt$star, $staropt$star$1, f1, f2, merge, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c1, (function (x) {
          var key = Curry._1(f1, x);
          try {
            var c = Curry._2(Tbl[/* find */6], tbl, key);
            c[/* ja_left */0] = /* :: */[
              x,
              c[/* ja_left */0]
            ];
            return /* () */0;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return Curry._3(Tbl[/* add */4], tbl, key, /* record */[
                          /* ja_left : :: */[
                            x,
                            /* [] */0
                          ],
                          /* ja_right : [] */0
                        ]);
            } else {
              throw exn;
            }
          }
        }));
  Curry._1(c2, (function (y) {
          var key = Curry._1(f2, y);
          try {
            var c = Curry._2(Tbl[/* find */6], tbl, key);
            c[/* ja_right */1] = /* :: */[
              y,
              c[/* ja_right */1]
            ];
            return /* () */0;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return Curry._3(Tbl[/* add */4], tbl, key, /* record */[
                          /* ja_left : [] */0,
                          /* ja_right : :: */[
                            y,
                            /* [] */0
                          ]
                        ]);
            } else {
              throw exn;
            }
          }
        }));
  var res = [/* [] */0];
  Curry._2(Tbl[/* iter */10], (function (key, cell) {
          var match = Curry._3(merge, key, cell[/* ja_left */0], cell[/* ja_right */1]);
          if (match) {
            res[0] = /* :: */[
              match[0],
              res[0]
            ];
            return /* () */0;
          } else {
            return /* () */0;
          }
        }), tbl);
  return (function ($$yield) {
      return List.iter($$yield, res[0]);
    });
}

function group_join_by($staropt$star, $staropt$star$1, f, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* [] */0);
        }));
  Curry._1(c2, (function (y) {
          var key = Curry._1(f, y);
          try {
            var l = Curry._2(Tbl[/* find */6], tbl, key);
            return Curry._3(Tbl[/* replace */8], tbl, key, /* :: */[
                        y,
                        l
                      ]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* () */0;
            } else {
              throw exn;
            }
          }
        }));
  return (function ($$yield) {
      return Curry._2(Tbl[/* iter */10], (function (k, l) {
                    return Curry._1($$yield, /* tuple */[
                                k,
                                l
                              ]);
                  }), tbl);
    });
}

function union($staropt$star, $staropt$star$1, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* () */0);
        }));
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* () */0);
        }));
  return (function ($$yield) {
      return Curry._2(Tbl[/* iter */10], (function (x, _) {
                    return Curry._1($$yield, x);
                  }), tbl);
    });
}

function inter($staropt$star, $staropt$star$1, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c1, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* Inter_left */0);
        }));
  Curry._1(c2, (function (x) {
          try {
            var match = Curry._2(Tbl[/* find */6], tbl, x);
            if (match !== 0) {
              return /* () */0;
            } else {
              return Curry._3(Tbl[/* replace */8], tbl, x, /* Inter_both */1);
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* () */0;
            } else {
              throw exn;
            }
          }
        }));
  return (function ($$yield) {
      return Curry._2(Tbl[/* iter */10], (function (x, res) {
                    if (res === /* Inter_both */1) {
                      return Curry._1($$yield, x);
                    } else {
                      return 0;
                    }
                  }), tbl);
    });
}

function diff($staropt$star, $staropt$star$1, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* () */0);
        }));
  return (function ($$yield) {
      return Curry._1(c1, (function (x) {
                    if (Curry._2(Tbl[/* mem */9], tbl, x)) {
                      return 0;
                    } else {
                      return Curry._1($$yield, x);
                    }
                  }));
    });
}

var Subset_exit = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.Subset_exit");

function subset($staropt$star, $staropt$star$1, c1, c2) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var hash = $staropt$star$1 ? $staropt$star$1[0] : Hashtbl.hash;
  var Tbl = Hashtbl.Make(/* module */[
        /* equal */eq,
        /* hash */hash
      ]);
  var tbl = Curry._1(Tbl[/* create */0], 32);
  Curry._1(c2, (function (x) {
          return Curry._3(Tbl[/* replace */8], tbl, x, /* () */0);
        }));
  try {
    Curry._1(c1, (function (x) {
            if (Curry._2(Tbl[/* mem */9], tbl, x)) {
              return 0;
            } else {
              throw Subset_exit;
            }
          }));
    return /* true */1;
  }
  catch (exn){
    if (exn === Subset_exit) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function unfoldr(f, _b, k) {
  while(true) {
    var b = _b;
    var match = Curry._1(f, b);
    if (match) {
      var match$1 = match[0];
      Curry._1(k, match$1[0]);
      _b = match$1[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function scan(f, acc, seq, k) {
  Curry._1(k, acc);
  var acc$1 = [acc];
  return Curry._1(seq, (function (elt) {
                var acc$prime = Curry._2(f, acc$1[0], elt);
                Curry._1(k, acc$prime);
                acc$1[0] = acc$prime;
                return /* () */0;
              }));
}

function max($staropt$star, seq) {
  var lt = $staropt$star ? $staropt$star[0] : Caml_obj.caml_lessthan;
  var ret = [/* None */0];
  Curry._1(seq, (function (x) {
          var match = ret[0];
          if (match) {
            if (Curry._2(lt, match[0], x)) {
              ret[0] = /* Some */[x];
              return /* () */0;
            } else {
              return 0;
            }
          } else {
            ret[0] = /* Some */[x];
            return /* () */0;
          }
        }));
  return ret[0];
}

function max_exn(lt, seq) {
  var match = max(lt, seq);
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function min($staropt$star, seq) {
  var lt = $staropt$star ? $staropt$star[0] : Caml_obj.caml_lessthan;
  var ret = [/* None */0];
  Curry._1(seq, (function (x) {
          var match = ret[0];
          if (match) {
            if (Curry._2(lt, x, match[0])) {
              ret[0] = /* Some */[x];
              return /* () */0;
            } else {
              return 0;
            }
          } else {
            ret[0] = /* Some */[x];
            return /* () */0;
          }
        }));
  return ret[0];
}

function min_exn(lt, seq) {
  var match = min(lt, seq);
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function sum(seq) {
  var n = [0];
  Curry._1(seq, (function (x) {
          n[0] = n[0] + x | 0;
          return /* () */0;
        }));
  return n[0];
}

function sumf(seq) {
  var sum = [0];
  var c = [0];
  Curry._1(seq, (function (x) {
          var y = x - c[0];
          var t = sum[0] + y;
          c[0] = t - sum[0] - y;
          sum[0] = t;
          return /* () */0;
        }));
  return sum[0];
}

var ExitHead = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitHead");

function head(seq) {
  var r = [/* None */0];
  try {
    Curry._1(seq, (function (x) {
            r[0] = /* Some */[x];
            throw ExitHead;
          }));
    return /* None */0;
  }
  catch (exn){
    if (exn === ExitHead) {
      return r[0];
    } else {
      throw exn;
    }
  }
}

function head_exn(seq) {
  var match = head(seq);
  if (match) {
    return match[0];
  } else {
    return Pervasives.invalid_arg("Sequence.head_exn");
  }
}

var ExitTake = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitTake");

function take(n, seq, k) {
  var count = [0];
  try {
    return Curry._1(seq, (function (x) {
                  if (count[0] === n) {
                    throw ExitTake;
                  }
                  count[0] = count[0] + 1 | 0;
                  return Curry._1(k, x);
                }));
  }
  catch (exn){
    if (exn === ExitTake) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

var ExitTakeWhile = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitTakeWhile");

function take_while(p, seq, k) {
  try {
    return Curry._1(seq, (function (x) {
                  if (Curry._1(p, x)) {
                    return Curry._1(k, x);
                  } else {
                    throw ExitTakeWhile;
                  }
                }));
  }
  catch (exn){
    if (exn === ExitTakeWhile) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

var ExitFoldWhile = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitFoldWhile");

function fold_while(f, s, seq) {
  var state = [s];
  var consume = function (x) {
    var match = Curry._2(f, state[0], x);
    state[0] = match[0];
    if (match[1] >= 926227490) {
      throw ExitFoldWhile;
    } else {
      return /* () */0;
    }
  };
  try {
    Curry._1(seq, consume);
    return state[0];
  }
  catch (exn){
    if (exn === ExitFoldWhile) {
      return state[0];
    } else {
      throw exn;
    }
  }
}

function drop(n, seq, k) {
  var count = [0];
  return Curry._1(seq, (function (x) {
                if (count[0] >= n) {
                  return Curry._1(k, x);
                } else {
                  count[0] = count[0] + 1 | 0;
                  return /* () */0;
                }
              }));
}

function drop_while(p, seq, k) {
  var drop = [/* true */1];
  return Curry._1(seq, (function (x) {
                if (drop[0]) {
                  if (Curry._1(p, x)) {
                    return /* () */0;
                  } else {
                    drop[0] = /* false */0;
                    return Curry._1(k, x);
                  }
                } else {
                  return Curry._1(k, x);
                }
              }));
}

function rev(seq) {
  var l = of_seq_with(seq, (function () {
          return /* () */0;
        }));
  return (function (k) {
      return iter_rev(k, l);
    });
}

var ExitForall = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitForall");

function for_all(p, seq) {
  try {
    Curry._1(seq, (function (x) {
            if (Curry._1(p, x)) {
              return 0;
            } else {
              throw ExitForall;
            }
          }));
    return /* true */1;
  }
  catch (exn){
    if (exn === ExitForall) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var ExitExists = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitExists");

function exists(p, seq) {
  try {
    Curry._1(seq, (function (x) {
            if (Curry._1(p, x)) {
              throw ExitExists;
            } else {
              return 0;
            }
          }));
    return /* false */0;
  }
  catch (exn){
    if (exn === ExitExists) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function mem($staropt$star, x, seq) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  return exists(Curry._1(eq, x), seq);
}

var ExitFind = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitFind");

function find_map(f, seq) {
  var r = [/* None */0];
  try {
    Curry._1(seq, (function (x) {
            var res = Curry._1(f, x);
            if (res) {
              r[0] = res;
              throw ExitFind;
            } else {
              return /* () */0;
            }
          }));
  }
  catch (exn){
    if (exn !== ExitFind) {
      throw exn;
    }
    
  }
  return r[0];
}

function find_mapi(f, seq) {
  var i = [0];
  var r = [/* None */0];
  try {
    Curry._1(seq, (function (x) {
            var res = Curry._2(f, i[0], x);
            if (res) {
              r[0] = res;
              throw ExitFind;
            } else {
              i[0] = i[0] + 1 | 0;
              return /* () */0;
            }
          }));
  }
  catch (exn){
    if (exn !== ExitFind) {
      throw exn;
    }
    
  }
  return r[0];
}

function find_pred(f, seq) {
  return find_map((function (x) {
                if (Curry._1(f, x)) {
                  return /* Some */[x];
                } else {
                  return /* None */0;
                }
              }), seq);
}

function find_pred_exn(f, seq) {
  var match = find_pred(f, seq);
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function length$1(seq) {
  var r = [0];
  Curry._1(seq, (function () {
          r[0] = r[0] + 1 | 0;
          return /* () */0;
        }));
  return r[0];
}

var ExitIsEmpty = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.ExitIsEmpty");

function is_empty(seq) {
  try {
    Curry._1(seq, (function () {
            throw ExitIsEmpty;
          }));
    return /* true */1;
  }
  catch (exn){
    if (exn === ExitIsEmpty) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function zip_i(seq, k) {
  var r = [0];
  return Curry._1(seq, (function (x) {
                var n = r[0];
                r[0] = r[0] + 1 | 0;
                return Curry._1(k, /* tuple */[
                            n,
                            x
                          ]);
              }));
}

function fold2(f, acc, seq2) {
  var acc$1 = [acc];
  Curry._1(seq2, (function (param) {
          acc$1[0] = Curry._3(f, acc$1[0], param[0], param[1]);
          return /* () */0;
        }));
  return acc$1[0];
}

function iter2(f, seq2) {
  return Curry._1(seq2, (function (param) {
                return Curry._2(f, param[0], param[1]);
              }));
}

function map2(f, seq2, k) {
  return Curry._1(seq2, (function (param) {
                return Curry._1(k, Curry._2(f, param[0], param[1]));
              }));
}

function map2_2(f, g, seq2, k) {
  return Curry._1(seq2, (function (param) {
                var y = param[1];
                var x = param[0];
                return Curry._1(k, /* tuple */[
                            Curry._2(f, x, y),
                            Curry._2(g, x, y)
                          ]);
              }));
}

function to_list(seq) {
  return List.rev(fold((function (y, x) {
                    return /* :: */[
                            x,
                            y
                          ];
                  }), /* [] */0, seq));
}

function to_rev_list(seq) {
  return fold((function (y, x) {
                return /* :: */[
                        x,
                        y
                      ];
              }), /* [] */0, seq);
}

function of_list(l, k) {
  return List.iter(k, l);
}

function on_list(f, l) {
  return to_list(Curry._1(f, (function (param) {
                    return List.iter(param, l);
                  })));
}

function pair_with_idx(seq, k) {
  var r = [0];
  return Curry._1(seq, (function (x) {
                var n = r[0];
                r[0] = r[0] + 1 | 0;
                return Curry._1(k, /* tuple */[
                            n,
                            x
                          ]);
              }));
}

function of_opt(o, k) {
  if (o) {
    return Curry._1(k, o[0]);
  } else {
    return /* () */0;
  }
}

function to_array(seq) {
  var l = of_seq_with(seq, (function () {
          return /* () */0;
        }));
  var n = length(l);
  if (n) {
    var a = Caml_array.caml_make_vect(n, get(l, 0));
    iteri$1((function (i, x) {
            return Caml_array.caml_array_set(a, i, x);
          }), l);
    return a;
  } else {
    return /* array */[];
  }
}

function of_array(a, k) {
  return $$Array.iter(k, a);
}

function of_array_i(a, k) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._1(k, /* tuple */[
          i,
          a[i]
        ]);
  }
  return /* () */0;
}

function array_slice(a, i, j, k) {
  if (!(i >= 0 && j < a.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "Sequence.ml",
            1028,
            2
          ]
        ];
  }
  for(var idx = i; idx <= j; ++idx){
    Curry._1(k, Caml_array.caml_array_get(a, idx));
  }
  return /* () */0;
}

function of_stream(s, k) {
  return Stream.iter(k, s);
}

function to_stream(seq) {
  var l = of_seq_with(seq, (function () {
          return /* () */0;
        }));
  return Stream.from(_to_next(42, l));
}

function to_stack(s, seq) {
  return Curry._1(seq, (function (x) {
                return Stack.push(x, s);
              }));
}

function of_stack(s, k) {
  return Stack.iter(k, s);
}

function to_queue(q, seq) {
  return Curry._1(seq, (function (x) {
                return Queue.push(x, q);
              }));
}

function of_queue(q, k) {
  return Queue.iter(k, q);
}

function hashtbl_add(h, seq) {
  return Curry._1(seq, (function (param) {
                return Hashtbl.add(h, param[0], param[1]);
              }));
}

function hashtbl_replace(h, seq) {
  return Curry._1(seq, (function (param) {
                return Hashtbl.replace(h, param[0], param[1]);
              }));
}

function to_hashtbl(seq) {
  var h = Hashtbl.create(/* None */0, 3);
  hashtbl_replace(h, seq);
  return h;
}

function of_hashtbl(h, k) {
  return Hashtbl.iter((function (a, b) {
                return Curry._1(k, /* tuple */[
                            a,
                            b
                          ]);
              }), h);
}

function hashtbl_keys(h, k) {
  return Hashtbl.iter((function (a, _) {
                return Curry._1(k, a);
              }), h);
}

function hashtbl_values(h, k) {
  return Hashtbl.iter((function (_, b) {
                return Curry._1(k, b);
              }), h);
}

function of_str(s, k) {
  return $$String.iter(k, s);
}

function to_str(seq) {
  var b = Buffer.create(64);
  Curry._1(seq, (function (c) {
          return Buffer.add_char(b, c);
        }));
  return Buffer.contents(b);
}

function concat_str(seq) {
  var b = Buffer.create(64);
  Curry._1(seq, (function (param) {
          return Buffer.add_string(b, param);
        }));
  return Buffer.contents(b);
}

var OneShotSequence = Caml_exceptions.create("Sequence-ReasonmlDemoIterators.OneShotSequence");

function of_in_channel(ic) {
  var first = [/* true */1];
  return (function (k) {
      if (first[0]) {
        first[0] = /* false */0;
        try {
          while(true) {
            Curry._1(k, Pervasives.input_char(ic));
          };
          return /* () */0;
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.end_of_file) {
            return /* () */0;
          } else {
            throw exn;
          }
        }
      } else {
        throw OneShotSequence;
      }
    });
}

function to_buffer(seq, buf) {
  return Curry._1(seq, (function (c) {
                return Buffer.add_char(buf, c);
              }));
}

function int_range(start, stop, k) {
  for(var i = start; i <= stop; ++i){
    Curry._1(k, i);
  }
  return /* () */0;
}

function int_range_dec(start, stop, k) {
  for(var i = start; i >= stop; --i){
    Curry._1(k, i);
  }
  return /* () */0;
}

function int_range_by(step, i, j, $$yield) {
  if (!step) {
    Pervasives.invalid_arg("int_range_by");
  }
  for(var k = 0 ,k_finish = Caml_int32.div(j - i | 0, step); k <= k_finish; ++k){
    Curry._1($$yield, Caml_int32.imul(k, step) + i | 0);
  }
  return /* () */0;
}

function bools(k) {
  Curry._1(k, /* false */0);
  return Curry._1(k, /* true */1);
}

function of_set(m, set) {
  return (function (k) {
      return Curry._2(m[/* iter */12], k, set);
    });
}

function to_set(m, seq) {
  return fold((function (set, x) {
                return Curry._2(m[/* add */3], x, set);
              }), m[/* empty */0], seq);
}

function of_gen(g) {
  var iter1 = function (k) {
    while(true) {
      var match = Curry._1(g, /* () */0);
      if (match) {
        Curry._1(k, match[0]);
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  var partial_arg = of_seq_with(iter1, (function () {
          return /* () */0;
        }));
  return (function (param) {
      return iter$1(param, partial_arg);
    });
}

function to_gen(seq) {
  return _to_next(/* () */0, of_seq_with(seq, (function () {
                    return /* () */0;
                  })));
}

function of_klist(_l, k) {
  while(true) {
    var l = _l;
    var match = Curry._1(l, /* () */0);
    if (typeof match === "number") {
      return /* () */0;
    } else {
      var match$1 = match[1];
      Curry._1(k, match$1[0]);
      _l = match$1[1];
      continue ;
      
    }
  };
}

function to_klist(seq) {
  var l = of_seq_with(seq, (function () {
          return /* () */0;
        }));
  var make = function (_param, _param$1) {
    while(true) {
      var param = _param;
      var l = param[0];
      if (l) {
        var i = param[1];
        if (i === l[1][0]) {
          _param$1 = /* () */0;
          _param = /* tuple */[
            l[2][0],
            0
          ];
          continue ;
          
        } else {
          var partial_arg_001 = i + 1 | 0;
          var partial_arg = /* tuple */[
            l,
            partial_arg_001
          ];
          return /* `Cons */[
                  748545553,
                  /* tuple */[
                    Caml_array.caml_array_get(l[0], i),
                    (function(partial_arg){
                    return function (param) {
                      return make(partial_arg, param);
                    }
                    }(partial_arg))
                  ]
                ];
        }
      } else {
        return /* Nil */3902385;
      }
    };
  };
  var partial_arg = /* tuple */[
    l,
    0
  ];
  return (function (param) {
      return make(partial_arg, param);
    });
}

function Adapt(X) {
  var to_seq = function (set, k) {
    return Curry._2(X[/* iter */12], k, set);
  };
  var of_seq = function (seq) {
    return fold((function (set, x) {
                  return Curry._2(X[/* add */3], x, set);
                }), X[/* empty */0], seq);
  };
  var to_list$1 = function (set) {
    return to_list((function (param) {
                  return Curry._2(X[/* iter */12], param, set);
                }));
  };
  var empty = X[0];
  var add = X[3];
  var of_list = function (l) {
    return List.fold_left((function (set, x) {
                  return Curry._2(add, x, set);
                }), empty, l);
  };
  return /* module */[
          /* empty */empty,
          /* is_empty */X[1],
          /* mem */X[2],
          /* add */add,
          /* singleton */X[4],
          /* remove */X[5],
          /* union */X[6],
          /* inter */X[7],
          /* diff */X[8],
          /* compare */X[9],
          /* equal */X[10],
          /* subset */X[11],
          /* iter */X[12],
          /* fold */X[13],
          /* for_all */X[14],
          /* exists */X[15],
          /* filter */X[16],
          /* partition */X[17],
          /* cardinal */X[18],
          /* elements */X[19],
          /* min_elt */X[20],
          /* max_elt */X[21],
          /* choose */X[22],
          /* split */X[23],
          /* find */X[24],
          /* of_seq */of_seq,
          /* to_seq */to_seq,
          /* to_list */to_list$1,
          /* of_list */of_list
        ];
}

function Make(V) {
  var M = $$Map.Make(V);
  var to_seq = function (m) {
    return (function (k) {
        return Curry._2(M[/* iter */9], (function (x, y) {
                      return Curry._1(k, /* tuple */[
                                  x,
                                  y
                                ]);
                    }), m);
      });
  };
  var of_seq = function (seq) {
    return fold((function (m, param) {
                  return Curry._3(M[/* add */3], param[0], param[1], m);
                }), M[/* empty */0], seq);
  };
  var keys = function (m) {
    return (function (k) {
        return Curry._2(M[/* iter */9], (function (x, _) {
                      return Curry._1(k, x);
                    }), m);
      });
  };
  var values = function (m) {
    return (function (k) {
        return Curry._2(M[/* iter */9], (function (_, y) {
                      return Curry._1(k, y);
                    }), m);
      });
  };
  var of_list = function (l) {
    return of_seq((function (param) {
                  return List.iter(param, l);
                }));
  };
  var to_list$1 = function (x) {
    return to_list(to_seq(x));
  };
  return /* module */[
          /* empty */M[0],
          /* is_empty */M[1],
          /* mem */M[2],
          /* add */M[3],
          /* singleton */M[4],
          /* remove */M[5],
          /* merge */M[6],
          /* compare */M[7],
          /* equal */M[8],
          /* iter */M[9],
          /* fold */M[10],
          /* for_all */M[11],
          /* exists */M[12],
          /* filter */M[13],
          /* partition */M[14],
          /* cardinal */M[15],
          /* bindings */M[16],
          /* min_binding */M[17],
          /* max_binding */M[18],
          /* choose */M[19],
          /* split */M[20],
          /* find */M[21],
          /* map */M[22],
          /* mapi */M[23],
          /* to_seq */to_seq,
          /* of_seq */of_seq,
          /* keys */keys,
          /* values */values,
          /* to_list */to_list$1,
          /* of_list */of_list
        ];
}

function random_int(bound) {
  return (function (param) {
      return forever((function () {
                    return Random.$$int(bound);
                  }), param);
    });
}

function random_bool(param) {
  return forever(Random.bool, param);
}

function random_float(bound) {
  return (function (param) {
      return forever((function () {
                    return Random.$$float(bound);
                  }), param);
    });
}

function random_array(a, k) {
  if (a.length <= 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "Sequence.ml",
            1261,
            2
          ]
        ];
  }
  while(true) {
    var i = Random.$$int(a.length);
    Curry._1(k, Caml_array.caml_array_get(a, i));
  };
  return /* () */0;
}

function random_list(l) {
  var partial_arg = $$Array.of_list(l);
  return (function (param) {
      return random_array(partial_arg, param);
    });
}

function shuffle_array(a) {
  for(var k = a.length - 1 | 0; k >= 1; --k){
    var l = Random.$$int(k + 1 | 0);
    var tmp = Caml_array.caml_array_get(a, l);
    Caml_array.caml_array_set(a, l, Caml_array.caml_array_get(a, k));
    Caml_array.caml_array_set(a, k, tmp);
  }
  return /* () */0;
}

function shuffle(seq) {
  var a = to_array(seq);
  shuffle_array(a);
  return (function (param) {
      return $$Array.iter(param, a);
    });
}

function shuffle_buffer(n, seq, k) {
  var seq_front = function (param) {
    return take(n, seq, param);
  };
  var a = to_array(seq_front);
  var l = a.length;
  if (l < n) {
    shuffle_array(a);
    return $$Array.iter(k, a);
  } else {
    return drop(n, seq, (function (x) {
                  var i = Random.$$int(n);
                  var y = Caml_array.caml_array_get(a, i);
                  Caml_array.caml_array_set(a, i, x);
                  return Curry._1(k, y);
                }));
  }
}

function sample(n, seq) {
  var match = head(seq);
  if (match) {
    var a = Caml_array.caml_make_vect(n, match[0]);
    var i = [-1];
    var f = function (x) {
      i[0] = i[0] + 1 | 0;
      if (i[0] < n) {
        return Caml_array.caml_array_set(a, i[0], x);
      } else {
        var j = Random.$$int(n);
        if (j <= n) {
          return Caml_array.caml_array_set(a, i[0], x);
        } else {
          return /* () */0;
        }
      }
    };
    Curry._1(seq, f);
    if (i[0] < n) {
      return $$Array.sub(a, 0, i[0]);
    } else {
      return a;
    }
  } else {
    return /* array */[];
  }
}

function $neg$neg(i, j) {
  return (function (param) {
      return int_range(i, j, param);
    });
}

function $neg$neg$caret(i, j) {
  return (function (param) {
      return int_range_dec(i, j, param);
    });
}

function $great$great$eq(x, f) {
  return (function (param) {
      return Curry._1(x, (function (x) {
                    return Curry._2(f, x, param);
                  }));
    });
}

function $great$pipe$eq(x, f) {
  return (function (param) {
      return Curry._1(x, (function (x) {
                    return Curry._1(param, Curry._1(f, x));
                  }));
    });
}

function $less$star$great(funs, args, k) {
  return Curry._1(funs, (function (f) {
                return Curry._1(args, (function (x) {
                              return Curry._1(k, Curry._1(f, x));
                            }));
              }));
}

var Infix = /* module */[
  /* -- */$neg$neg,
  /* --^ */$neg$neg$caret,
  /* >>= */$great$great$eq,
  /* >|= */$great$pipe$eq,
  /* <*> */$less$star$great,
  /* <+> */append
];

function pp_seq($staropt$star, pp_elt, formatter, seq) {
  var sep = $staropt$star ? $staropt$star[0] : ", ";
  var first = [/* true */1];
  return Curry._1(seq, (function (x) {
                if (first[0]) {
                  first[0] = /* false */0;
                } else {
                  Format.pp_print_string(formatter, sep);
                  Format.pp_print_cut(formatter, /* () */0);
                }
                return Curry._2(pp_elt, formatter, x);
              }));
}

function pp_buf($staropt$star, pp_elt, buf, seq) {
  var sep = $staropt$star ? $staropt$star[0] : ", ";
  var first = [/* true */1];
  return Curry._1(seq, (function (x) {
                if (first[0]) {
                  first[0] = /* false */0;
                } else {
                  Buffer.add_string(buf, sep);
                }
                return Curry._2(pp_elt, buf, x);
              }));
}

function to_string(sep, pp_elt, seq) {
  var buf = Buffer.create(25);
  pp_buf(sep, (function (buf, x) {
          return Buffer.add_string(buf, Curry._1(pp_elt, x));
        }), buf, seq);
  return Buffer.contents(buf);
}

function lines_of($staropt$star, $staropt$star$1, filename, k) {
  var mode = $staropt$star ? $staropt$star[0] : 420;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : /* :: */[
      /* Open_rdonly */0,
      /* [] */0
    ];
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    while(true) {
      Curry._1(k, Pervasives.input_line(ic));
    };
    return /* () */0;
  }
  catch (e){
    if (e === Caml_builtin_exceptions.end_of_file) {
      return Pervasives.close_in(ic);
    } else {
      Pervasives.close_in_noerr(ic);
      throw e;
    }
  }
}

function chunks_of($staropt$star, $staropt$star$1, $staropt$star$2, filename, k) {
  var mode = $staropt$star ? $staropt$star[0] : 420;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var size = $staropt$star$2 ? $staropt$star$2[0] : 1024;
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    var buf = Caml_string.caml_create_string(size);
    var n = 0;
    var stop = /* false */0;
    while(!stop) {
      n = 0;
      while(n < size && !stop) {
        var n$prime = Pervasives.input(ic, buf, n, size - n | 0);
        if (n$prime) {
          n = n + n$prime | 0;
        } else {
          stop = /* true */1;
        }
      };
      if (n > 0) {
        Curry._1(k, Bytes.sub_string(buf, 0, n));
      }
      
    };
    return Pervasives.close_in(ic);
  }
  catch (e){
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function write_bytes_to($staropt$star, $staropt$star$1, filename, seq) {
  var mode = $staropt$star ? $staropt$star[0] : 420;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : /* :: */[
      /* Open_creat */3,
      /* :: */[
        /* Open_wronly */1,
        /* [] */0
      ]
    ];
  var oc = Pervasives.open_out_gen(flags, mode, filename);
  try {
    Curry._1(seq, (function (s) {
            return Pervasives.output(oc, s, 0, s.length);
          }));
    return Pervasives.close_out(oc);
  }
  catch (e){
    Pervasives.close_out(oc);
    throw e;
  }
}

function write_to(mode, flags, filename, seq) {
  return write_bytes_to(mode, flags, filename, (function (param) {
                return Curry._1(seq, (function (x) {
                              return Curry._1(param, Bytes.unsafe_of_string(x));
                            }));
              }));
}

function write_bytes_lines(mode, flags, filename, seq) {
  var ret = Bytes.unsafe_of_string("\n");
  return write_bytes_to(mode, flags, filename, (function (param) {
                intersperse(ret, seq, param);
                return Curry._1(param, ret);
              }));
}

function write_lines(mode, flags, filename, seq) {
  return write_bytes_lines(mode, flags, filename, (function (param) {
                return Curry._1(seq, (function (x) {
                              return Curry._1(param, Bytes.unsafe_of_string(x));
                            }));
              }));
}

var find = find_map;

var findi = find_mapi;

var to_opt = head;

function Set_001(funarg) {
  var MySet = $$Set.Make(funarg);
  var to_seq = function (set, k) {
    return Curry._2(MySet[/* iter */12], k, set);
  };
  var of_seq = function (seq) {
    return fold((function (set, x) {
                  return Curry._2(MySet[/* add */3], x, set);
                }), MySet[/* empty */0], seq);
  };
  var to_list$1 = function (set) {
    return to_list(Curry._1(to_seq, set));
  };
  var empty = MySet[0];
  var add = MySet[3];
  var of_list = function (l) {
    return List.fold_left((function (set, x) {
                  return Curry._2(add, x, set);
                }), empty, l);
  };
  var include_001 = /* is_empty */MySet[1];
  var include_002 = /* mem */MySet[2];
  var include_004 = /* singleton */MySet[4];
  var include_005 = /* remove */MySet[5];
  var include_006 = /* union */MySet[6];
  var include_007 = /* inter */MySet[7];
  var include_008 = /* diff */MySet[8];
  var include_009 = /* compare */MySet[9];
  var include_010 = /* equal */MySet[10];
  var include_011 = /* subset */MySet[11];
  var include_012 = /* iter */MySet[12];
  var include_013 = /* fold */MySet[13];
  var include_014 = /* for_all */MySet[14];
  var include_015 = /* exists */MySet[15];
  var include_016 = /* filter */MySet[16];
  var include_017 = /* partition */MySet[17];
  var include_018 = /* cardinal */MySet[18];
  var include_019 = /* elements */MySet[19];
  var include_020 = /* min_elt */MySet[20];
  var include_021 = /* max_elt */MySet[21];
  var include_022 = /* choose */MySet[22];
  var include_023 = /* split */MySet[23];
  var include_024 = /* find */MySet[24];
  var let_001 = /* empty */empty;
  var let_002 = include_001;
  var let_003 = include_002;
  var let_004 = /* add */add;
  var let_005 = include_004;
  var let_006 = include_005;
  var let_007 = include_006;
  var let_008 = include_007;
  var let_009 = include_008;
  var let_010 = include_009;
  var let_011 = include_010;
  var let_012 = include_011;
  var let_013 = include_012;
  var let_014 = include_013;
  var let_015 = include_014;
  var let_016 = include_015;
  var let_017 = include_016;
  var let_018 = include_017;
  var let_019 = include_018;
  var let_020 = include_019;
  var let_021 = include_020;
  var let_022 = include_021;
  var let_023 = include_022;
  var let_024 = include_023;
  var let_025 = include_024;
  var let_026 = /* of_seq */of_seq;
  var let_027 = /* to_seq */to_seq;
  var let_028 = /* to_list */to_list$1;
  var let_029 = /* of_list */of_list;
  return [
          let_001,
          let_002,
          let_003,
          let_004,
          let_005,
          let_006,
          let_007,
          let_008,
          let_009,
          let_010,
          let_011,
          let_012,
          let_013,
          let_014,
          let_015,
          let_016,
          let_017,
          let_018,
          let_019,
          let_020,
          let_021,
          let_022,
          let_023,
          let_024,
          let_025,
          let_026,
          let_027,
          let_028,
          let_029
        ];
}

var $$Set$1 = [
  Adapt,
  Set_001
];

function Map_000(funarg) {
  var to_seq = function (m) {
    return (function (k) {
        return Curry._2(funarg[/* iter */9], (function (x, y) {
                      return Curry._1(k, /* tuple */[
                                  x,
                                  y
                                ]);
                    }), m);
      });
  };
  var of_seq = function (seq) {
    return fold((function (m, param) {
                  return Curry._3(funarg[/* add */3], param[0], param[1], m);
                }), funarg[/* empty */0], seq);
  };
  var keys = function (m) {
    return (function (k) {
        return Curry._2(funarg[/* iter */9], (function (x, _) {
                      return Curry._1(k, x);
                    }), m);
      });
  };
  var values = function (m) {
    return (function (k) {
        return Curry._2(funarg[/* iter */9], (function (_, y) {
                      return Curry._1(k, y);
                    }), m);
      });
  };
  var of_list$1 = function (l) {
    return Curry._1(of_seq, (function (param) {
                  return of_list(l, param);
                }));
  };
  var to_list$1 = function (x) {
    return to_list(Curry._1(to_seq, x));
  };
  var let_006 = /* empty */funarg[0];
  var let_007 = /* is_empty */funarg[1];
  var let_008 = /* mem */funarg[2];
  var let_009 = /* add */funarg[3];
  var let_010 = /* singleton */funarg[4];
  var let_011 = /* remove */funarg[5];
  var let_012 = /* merge */funarg[6];
  var let_013 = /* compare */funarg[7];
  var let_014 = /* equal */funarg[8];
  var let_015 = /* iter */funarg[9];
  var let_016 = /* fold */funarg[10];
  var let_017 = /* for_all */funarg[11];
  var let_018 = /* exists */funarg[12];
  var let_019 = /* filter */funarg[13];
  var let_020 = /* partition */funarg[14];
  var let_021 = /* cardinal */funarg[15];
  var let_022 = /* bindings */funarg[16];
  var let_023 = /* min_binding */funarg[17];
  var let_024 = /* max_binding */funarg[18];
  var let_025 = /* choose */funarg[19];
  var let_026 = /* split */funarg[20];
  var let_027 = /* find */funarg[21];
  var let_028 = /* map */funarg[22];
  var let_029 = /* mapi */funarg[23];
  return [
          let_006,
          let_007,
          let_008,
          let_009,
          let_010,
          let_011,
          let_012,
          let_013,
          let_014,
          let_015,
          let_016,
          let_017,
          let_018,
          let_019,
          let_020,
          let_021,
          let_022,
          let_023,
          let_024,
          let_025,
          let_026,
          let_027,
          let_028,
          let_029,
          /* to_seq */to_seq,
          /* of_seq */of_seq,
          /* keys */keys,
          /* values */values,
          /* to_list */to_list$1,
          /* of_list */of_list$1
        ];
}

var $$Map$1 = [
  Map_000,
  Make
];

var $less$plus$great = append;

var IO = [
  lines_of,
  chunks_of,
  write_to,
  write_bytes_to,
  write_lines,
  write_bytes_lines
];

exports.from_iter        = from_iter;
exports.from_fun         = from_fun;
exports.empty            = empty;
exports.singleton        = singleton;
exports.doubleton        = doubleton;
exports.init             = init;
exports.cons             = cons;
exports.snoc             = snoc;
exports.$$return         = $$return;
exports.pure             = pure;
exports.repeat           = repeat;
exports.iterate          = iterate;
exports.forever          = forever;
exports.cycle            = cycle;
exports.iter             = iter;
exports.iteri            = iteri;
exports.fold             = fold;
exports.foldi            = foldi;
exports.fold_map         = fold_map;
exports.fold_filter_map  = fold_filter_map;
exports.map              = map;
exports.mapi             = mapi;
exports.map_by_2         = map_by_2;
exports.for_all          = for_all;
exports.exists           = exists;
exports.mem              = mem;
exports.find             = find;
exports.find_map         = find_map;
exports.findi            = findi;
exports.find_mapi        = find_mapi;
exports.find_pred        = find_pred;
exports.find_pred_exn    = find_pred_exn;
exports.length           = length$1;
exports.is_empty         = is_empty;
exports.filter           = filter;
exports.append           = append;
exports.append_l         = append_l;
exports.concat           = concat;
exports.flatten          = flatten;
exports.flat_map         = flat_map;
exports.flat_map_l       = flat_map_l;
exports.seq_list         = seq_list;
exports.seq_list_map     = seq_list_map;
exports.filter_map       = filter_map;
exports.filter_mapi      = filter_mapi;
exports.filter_count     = filter_count;
exports.intersperse      = intersperse;
exports.keep_some        = keep_some;
exports.keep_ok          = keep_ok;
exports.keep_error       = keep_error;
exports.persistent       = persistent;
exports.persistent_lazy  = persistent_lazy;
exports.sort             = sort;
exports.sort_uniq        = sort_uniq;
exports.sorted           = sorted;
exports.group_succ_by    = group_succ_by;
exports.group_by         = group_by;
exports.count            = count;
exports.uniq             = uniq;
exports.product          = product;
exports.diagonal_l       = diagonal_l;
exports.diagonal         = diagonal;
exports.join             = join;
exports.join_by          = join_by;
exports.join_all_by      = join_all_by;
exports.group_join_by    = group_join_by;
exports.inter            = inter;
exports.union            = union;
exports.diff             = diff;
exports.subset           = subset;
exports.unfoldr          = unfoldr;
exports.scan             = scan;
exports.max              = max;
exports.max_exn          = max_exn;
exports.min              = min;
exports.min_exn          = min_exn;
exports.sum              = sum;
exports.sumf             = sumf;
exports.head             = head;
exports.head_exn         = head_exn;
exports.take             = take;
exports.take_while       = take_while;
exports.fold_while       = fold_while;
exports.drop             = drop;
exports.drop_while       = drop_while;
exports.rev              = rev;
exports.zip_i            = zip_i;
exports.fold2            = fold2;
exports.iter2            = iter2;
exports.map2             = map2;
exports.map2_2           = map2_2;
exports.to_list          = to_list;
exports.to_rev_list      = to_rev_list;
exports.of_list          = of_list;
exports.on_list          = on_list;
exports.pair_with_idx    = pair_with_idx;
exports.to_opt           = to_opt;
exports.to_array         = to_array;
exports.of_array         = of_array;
exports.of_array_i       = of_array_i;
exports.array_slice      = array_slice;
exports.of_opt           = of_opt;
exports.of_stream        = of_stream;
exports.to_stream        = to_stream;
exports.to_stack         = to_stack;
exports.of_stack         = of_stack;
exports.to_queue         = to_queue;
exports.of_queue         = of_queue;
exports.hashtbl_add      = hashtbl_add;
exports.hashtbl_replace  = hashtbl_replace;
exports.to_hashtbl       = to_hashtbl;
exports.of_hashtbl       = of_hashtbl;
exports.hashtbl_keys     = hashtbl_keys;
exports.hashtbl_values   = hashtbl_values;
exports.of_str           = of_str;
exports.to_str           = to_str;
exports.concat_str       = concat_str;
exports.OneShotSequence  = OneShotSequence;
exports.of_in_channel    = of_in_channel;
exports.to_buffer        = to_buffer;
exports.int_range        = int_range;
exports.int_range_dec    = int_range_dec;
exports.int_range_by     = int_range_by;
exports.bools            = bools;
exports.of_set           = of_set;
exports.to_set           = to_set;
exports.of_gen           = of_gen;
exports.to_gen           = to_gen;
exports.of_klist         = of_klist;
exports.to_klist         = to_klist;
exports.$$Set            = $$Set$1;
exports.$$Map            = $$Map$1;
exports.random_int       = random_int;
exports.random_bool      = random_bool;
exports.random_float     = random_float;
exports.random_array     = random_array;
exports.random_list      = random_list;
exports.shuffle          = shuffle;
exports.shuffle_buffer   = shuffle_buffer;
exports.sample           = sample;
exports.Infix            = Infix;
exports.$neg$neg         = $neg$neg;
exports.$neg$neg$caret   = $neg$neg$caret;
exports.$great$great$eq  = $great$great$eq;
exports.$great$pipe$eq   = $great$pipe$eq;
exports.$less$star$great = $less$star$great;
exports.$less$plus$great = $less$plus$great;
exports.pp_seq           = pp_seq;
exports.pp_buf           = pp_buf;
exports.to_string        = to_string;
exports.IO               = IO;
/* Format Not a pure module */
