// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                           = require("bs-platform/lib/js/list.js");
var $$Array                        = require("bs-platform/lib/js/array.js");
var Block                          = require("bs-platform/lib/js/block.js");
var Curry                          = require("bs-platform/lib/js/curry.js");
var Queue                          = require("bs-platform/lib/js/queue.js");
var Buffer                         = require("bs-platform/lib/js/buffer.js");
var Format                         = require("bs-platform/lib/js/format.js");
var Random                         = require("bs-platform/lib/js/random.js");
var Caml_obj                       = require("bs-platform/lib/js/caml_obj.js");
var Caml_array                     = require("bs-platform/lib/js/caml_array.js");
var Caml_int32                     = require("bs-platform/lib/js/caml_int32.js");
var Pervasives                     = require("bs-platform/lib/js/pervasives.js");
var Caml_string                    = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions        = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var GenMList$ReasonmlDemoIterators = require("./genMList.bs.js");

function empty() {
  return /* None */0;
}

function singleton(x) {
  var first = [/* true */1];
  return (function () {
      if (first[0]) {
        first[0] = /* false */0;
        return /* Some */[x];
      } else {
        return /* None */0;
      }
    });
}

function repeat(x, _) {
  return /* Some */[x];
}

function repeatedly(f, _) {
  return /* Some */[Curry._1(f, /* () */0)];
}

function iterate(x, f) {
  var cur = [x];
  return (function () {
      var x = cur[0];
      cur[0] = Curry._1(f, cur[0]);
      return /* Some */[x];
    });
}

function next(gen) {
  return Curry._1(gen, /* () */0);
}

function get(gen) {
  return Curry._1(gen, /* () */0);
}

function get_exn(gen) {
  var match = Curry._1(gen, /* () */0);
  if (match) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Gen.get_exn"
        ];
  }
}

function junk(gen) {
  Curry._1(gen, /* () */0);
  return /* () */0;
}

function fold(f, _acc, gen) {
  while(true) {
    var acc = _acc;
    var match = Curry._1(gen, /* () */0);
    if (match) {
      _acc = Curry._2(f, acc, match[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function reduce(f, g) {
  var match = Curry._1(g, /* () */0);
  var acc;
  if (match) {
    acc = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "reduce"
        ];
  }
  return fold(f, acc, g);
}

function unfold(f, acc) {
  var acc$1 = [acc];
  return (function () {
      var match = Curry._1(f, acc$1[0]);
      if (match) {
        var match$1 = match[0];
        acc$1[0] = match$1[1];
        return /* Some */[match$1[0]];
      } else {
        return /* None */0;
      }
    });
}

function init($staropt$star, f) {
  var limit = $staropt$star ? $staropt$star[0] : Pervasives.max_int;
  var r = [0];
  return (function () {
      if (r[0] >= limit) {
        return /* None */0;
      } else {
        var x = Curry._1(f, r[0]);
        r[0] = r[0] + 1 | 0;
        return /* Some */[x];
      }
    });
}

function iter(f, gen) {
  while(true) {
    var match = Curry._1(gen, /* () */0);
    if (match) {
      Curry._1(f, match[0]);
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iteri(f, gen) {
  var _i = 0;
  while(true) {
    var i = _i;
    var match = Curry._1(gen, /* () */0);
    if (match) {
      Curry._2(f, i, match[0]);
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function is_empty(gen) {
  var match = Curry._1(gen, /* () */0);
  if (match) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function length(gen) {
  return fold((function (acc, _) {
                return acc + 1 | 0;
              }), 0, gen);
}

var RunState = /* module */[];

function scan(f, acc, g) {
  var state = [/* Init */0];
  return (function () {
      var match = state[0];
      if (typeof match === "number") {
        if (match !== 0) {
          return /* None */0;
        } else {
          state[0] = /* Run */[acc];
          return /* Some */[acc];
        }
      } else {
        var match$1 = Curry._1(g, /* () */0);
        if (match$1) {
          var acc$prime = Curry._2(f, match[0], match$1[0]);
          state[0] = /* Run */[acc$prime];
          return /* Some */[acc$prime];
        } else {
          state[0] = /* Stop */1;
          return /* None */0;
        }
      }
    });
}

function unfold_scan(f, acc, g) {
  var state = [/* Run */[acc]];
  return (function () {
      var match = state[0];
      if (typeof match === "number") {
        if (match !== 0) {
          return /* None */0;
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "gen.ml",
                  227,
                  14
                ]
              ];
        }
      } else {
        var match$1 = Curry._1(g, /* () */0);
        if (match$1) {
          var match$2 = Curry._2(f, match[0], match$1[0]);
          state[0] = /* Run */[match$2[0]];
          return /* Some */[match$2[1]];
        } else {
          state[0] = /* Stop */1;
          return /* None */0;
        }
      }
    });
}

function map(f, gen) {
  var stop = [/* false */0];
  return (function () {
      if (stop[0]) {
        return /* None */0;
      } else {
        var match = Curry._1(gen, /* () */0);
        if (match) {
          return /* Some */[Curry._1(f, match[0])];
        } else {
          stop[0] = /* true */1;
          return /* None */0;
        }
      }
    });
}

function mapi(f) {
  var cnt = [0];
  return (function (param) {
      return map((function (x) {
                    var i = cnt[0];
                    cnt[0] = i + 1 | 0;
                    return Curry._2(f, i, x);
                  }), param);
    });
}

function fold_map(f, s, gen) {
  var state = [s];
  return map((function (x) {
                state[0] = Curry._2(f, state[0], x);
                return state[0];
              }), gen);
}

function append(gen1, gen2) {
  var first = [/* true */1];
  return (function () {
      if (first[0]) {
        var x = Curry._1(gen1, /* () */0);
        if (x) {
          return x;
        } else {
          first[0] = /* false */0;
          return Curry._1(gen2, /* () */0);
        }
      } else {
        return Curry._1(gen2, /* () */0);
      }
    });
}

function flatten(next_gen) {
  var state = [/* Init */0];
  var next = function () {
    var match = state[0];
    if (typeof match === "number") {
      if (match !== 0) {
        return /* None */0;
      } else {
        return get_next_gen(/* () */0);
      }
    } else {
      var x = Curry._1(match[0], /* () */0);
      if (x) {
        return x;
      } else {
        return get_next_gen(/* () */0);
      }
    }
  };
  var get_next_gen = function () {
    var match = Curry._1(next_gen, /* () */0);
    if (match) {
      state[0] = /* Run */[match[0]];
      return next(/* () */0);
    } else {
      state[0] = /* Stop */1;
      return /* None */0;
    }
  };
  return next;
}

function flat_map(f, next_elem) {
  var state = [/* Init */0];
  var next = function () {
    var match = state[0];
    if (typeof match === "number") {
      if (match !== 0) {
        return /* None */0;
      } else {
        return get_next_gen(/* () */0);
      }
    } else {
      var x = Curry._1(match[0], /* () */0);
      if (x) {
        return x;
      } else {
        return get_next_gen(/* () */0);
      }
    }
  };
  var get_next_gen = function () {
    var match = Curry._1(next_elem, /* () */0);
    if (match) {
      try {
        state[0] = /* Run */[Curry._1(f, match[0])];
      }
      catch (e){
        state[0] = /* Stop */1;
        throw e;
      }
      return next(/* () */0);
    } else {
      state[0] = /* Stop */1;
      return /* None */0;
    }
  };
  return next;
}

function mem($staropt$star, x, gen) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var eq$1 = eq;
  var x$1 = x;
  var gen$1 = gen;
  while(true) {
    var match = Curry._1(gen$1, /* () */0);
    if (match) {
      if (Curry._2(eq$1, x$1, match[0])) {
        return /* true */1;
      } else {
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function take(n, gen) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            372,
            2
          ]
        ];
  }
  var count = [0];
  return (function () {
      if (count[0] === n || count[0] === -1) {
        return /* None */0;
      } else {
        var x = Curry._1(gen, /* () */0);
        if (x) {
          count[0] = count[0] + 1 | 0;
          return x;
        } else {
          count[0] = -1;
          return /* None */0;
        }
      }
    });
}

function __drop(_n, gen) {
  while(true) {
    var n = _n;
    if (n) {
      var match = Curry._1(gen, /* () */0);
      if (match) {
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function drop(n, gen) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            394,
            2
          ]
        ];
  }
  var dropped = [/* false */0];
  return (function () {
      if (dropped[0]) {
        return Curry._1(gen, /* () */0);
      } else {
        dropped[0] = /* true */1;
        __drop(n, gen);
        return Curry._1(gen, /* () */0);
      }
    });
}

function nth(n, gen) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            413,
            2
          ]
        ];
  }
  __drop(n, gen);
  var match = Curry._1(gen, /* () */0);
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function take_nth(n, gen) {
  if (n < 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            429,
            2
          ]
        ];
  }
  var i = [n];
  var next = function (_param) {
    while(true) {
      var res = Curry._1(gen, /* () */0);
      if (res) {
        if (i[0] === n) {
          i[0] = 1;
          return res;
        } else {
          i[0] = i[0] + 1 | 0;
          _param = /* () */0;
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  return next;
}

function filter(p, gen) {
  var next = function (_param) {
    while(true) {
      var res = Curry._1(gen, /* () */0);
      if (res) {
        if (Curry._1(p, res[0])) {
          return res;
        } else {
          _param = /* () */0;
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  return next;
}

function take_while(p, gen) {
  var stop = [/* false */0];
  return (function () {
      if (stop[0]) {
        return /* None */0;
      } else {
        var res = Curry._1(gen, /* () */0);
        if (res && Curry._1(p, res[0])) {
          return res;
        } else {
          stop[0] = /* true */1;
          return /* None */0;
        }
      }
    });
}

function fold_while(f, s, gen) {
  var state = [s];
  var consume = function (gen) {
    while(true) {
      var match = Curry._1(gen, /* () */0);
      if (match) {
        var match$1 = Curry._2(f, state[0], match[0]);
        state[0] = match$1[0];
        if (match$1[1] >= 926227490) {
          return /* () */0;
        } else {
          continue ;
          
        }
      } else {
        return /* () */0;
      }
    };
  };
  consume(gen);
  return state[0];
}

var DropWhileState = /* module */[];

function drop_while(p, gen) {
  var state = [/* Drop */1];
  var next = function (_param) {
    while(true) {
      var match = state[0];
      switch (match) {
        case 0 : 
            return /* None */0;
        case 1 : 
            var res = Curry._1(gen, /* () */0);
            if (res) {
              if (Curry._1(p, res[0])) {
                _param = /* () */0;
                continue ;
                
              } else {
                state[0] = /* Yield */2;
                return res;
              }
            } else {
              state[0] = /* Stop */0;
              return /* None */0;
            }
            break;
        case 2 : 
            var res$1 = Curry._1(gen, /* () */0);
            if (res$1) {
              return res$1;
            } else {
              state[0] = /* Stop */0;
              return /* None */0;
            }
        
      }
    };
  };
  return next;
}

function filter_map(f, gen) {
  var next = function (_param) {
    while(true) {
      var match = Curry._1(gen, /* () */0);
      if (match) {
        var res = Curry._1(f, match[0]);
        if (res) {
          return res;
        } else {
          _param = /* () */0;
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  return next;
}

function zip_index(gen) {
  var r = [-1];
  return (function () {
      var match = Curry._1(gen, /* () */0);
      if (match) {
        r[0] = r[0] + 1 | 0;
        return /* Some */[/* tuple */[
                  r[0],
                  match[0]
                ]];
      } else {
        return /* None */0;
      }
    });
}

function unzip(gen) {
  var stop = [/* false */0];
  var q1 = Queue.create(/* () */0);
  var q2 = Queue.create(/* () */0);
  var next_left = function () {
    if (Queue.is_empty(q1)) {
      if (stop[0]) {
        return /* None */0;
      } else {
        var match = Curry._1(gen, /* () */0);
        if (match) {
          var match$1 = match[0];
          Queue.push(match$1[1], q2);
          return /* Some */[match$1[0]];
        } else {
          stop[0] = /* true */1;
          return /* None */0;
        }
      }
    } else {
      return /* Some */[Queue.pop(q1)];
    }
  };
  var next_right = function () {
    if (Queue.is_empty(q2)) {
      if (stop[0]) {
        return /* None */0;
      } else {
        var match = Curry._1(gen, /* () */0);
        if (match) {
          var match$1 = match[0];
          Queue.push(match$1[0], q1);
          return /* Some */[match$1[1]];
        } else {
          stop[0] = /* true */1;
          return /* None */0;
        }
      }
    } else {
      return /* Some */[Queue.pop(q2)];
    }
  };
  return /* tuple */[
          next_left,
          next_right
        ];
}

function partition(p, gen) {
  var qtrue = Queue.create(/* () */0);
  var qfalse = Queue.create(/* () */0);
  var stop = [/* false */0];
  var nexttrue = function (_param) {
    while(true) {
      if (Queue.is_empty(qtrue)) {
        if (stop[0]) {
          return /* None */0;
        } else {
          var res = Curry._1(gen, /* () */0);
          if (res) {
            var x = res[0];
            if (Curry._1(p, x)) {
              return res;
            } else {
              Queue.push(x, qfalse);
              _param = /* () */0;
              continue ;
              
            }
          } else {
            stop[0] = /* true */1;
            return /* None */0;
          }
        }
      } else {
        return /* Some */[Queue.pop(qtrue)];
      }
    };
  };
  var nextfalse = function (_param) {
    while(true) {
      if (Queue.is_empty(qfalse)) {
        if (stop[0]) {
          return /* None */0;
        } else {
          var res = Curry._1(gen, /* () */0);
          if (res) {
            var x = res[0];
            if (Curry._1(p, x)) {
              Queue.push(x, qtrue);
              _param = /* () */0;
              continue ;
              
            } else {
              return res;
            }
          } else {
            stop[0] = /* true */1;
            return /* None */0;
          }
        }
      } else {
        return /* Some */[Queue.pop(qfalse)];
      }
    };
  };
  return /* tuple */[
          nexttrue,
          nextfalse
        ];
}

function for_all(p, gen) {
  while(true) {
    var match = Curry._1(gen, /* () */0);
    if (match) {
      if (Curry._1(p, match[0])) {
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function exists(p, gen) {
  while(true) {
    var match = Curry._1(gen, /* () */0);
    if (match) {
      if (Curry._1(p, match[0])) {
        return /* true */1;
      } else {
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function min($staropt$star, gen) {
  var lt = $staropt$star ? $staropt$star[0] : Caml_obj.caml_lessthan;
  var match = Curry._1(gen, /* () */0);
  var first;
  if (match) {
    first = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "min"
        ];
  }
  return fold((function (min, x) {
                if (Curry._2(lt, x, min)) {
                  return x;
                } else {
                  return min;
                }
              }), first, gen);
}

function max($staropt$star, gen) {
  var lt = $staropt$star ? $staropt$star[0] : Caml_obj.caml_lessthan;
  var match = Curry._1(gen, /* () */0);
  var first;
  if (match) {
    first = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "max"
        ];
  }
  return fold((function (max, x) {
                if (Curry._2(lt, max, x)) {
                  return x;
                } else {
                  return max;
                }
              }), first, gen);
}

function eq($staropt$star, gen1, gen2) {
  var eq$1 = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var _param = /* () */0;
  while(true) {
    var match = Curry._1(gen1, /* () */0);
    var match$1 = Curry._1(gen2, /* () */0);
    if (match) {
      if (match$1) {
        if (Curry._2(eq$1, match[0], match$1[0])) {
          _param = /* () */0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else if (match$1) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

function lexico($staropt$star, gen1, gen2) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var _param = /* () */0;
  while(true) {
    var match = Curry._1(gen1, /* () */0);
    var match$1 = Curry._1(gen2, /* () */0);
    if (match) {
      if (match$1) {
        var c = Curry._2(cmp, match[0], match$1[0]);
        if (c !== 0) {
          return c;
        } else {
          _param = /* () */0;
          continue ;
          
        }
      } else {
        return 1;
      }
    } else if (match$1) {
      return -1;
    } else {
      return 0;
    }
  };
}

var compare = lexico;

function find(p, e) {
  while(true) {
    var match = Curry._1(e, /* () */0);
    if (match) {
      var x = match[0];
      if (Curry._1(p, x)) {
        return /* Some */[x];
      } else {
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function sum(e) {
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var match = Curry._1(e, /* () */0);
    if (match) {
      _acc = match[0] + acc | 0;
      continue ;
      
    } else {
      return acc;
    }
  };
}

function map2(f, e1, e2, _) {
  var match = Curry._1(e1, /* () */0);
  var match$1 = Curry._1(e2, /* () */0);
  if (match && match$1) {
    return /* Some */[Curry._2(f, match[0], match$1[0])];
  } else {
    return /* None */0;
  }
}

function iter2(f, e1, e2) {
  while(true) {
    var match = Curry._1(e1, /* () */0);
    var match$1 = Curry._1(e2, /* () */0);
    if (match) {
      if (match$1) {
        Curry._2(f, match[0], match$1[0]);
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function fold2(f, _acc, e1, e2) {
  while(true) {
    var acc = _acc;
    var match = Curry._1(e1, /* () */0);
    var match$1 = Curry._1(e2, /* () */0);
    if (match) {
      if (match$1) {
        _acc = Curry._3(f, acc, match[0], match$1[0]);
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function for_all2(p, e1, e2) {
  while(true) {
    var match = Curry._1(e1, /* () */0);
    var match$1 = Curry._1(e2, /* () */0);
    if (match) {
      if (match$1) {
        if (Curry._2(p, match[0], match$1[0])) {
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    } else {
      return /* true */1;
    }
  };
}

function exists2(p, e1, e2) {
  while(true) {
    var match = Curry._1(e1, /* () */0);
    var match$1 = Curry._1(e2, /* () */0);
    if (match) {
      if (match$1) {
        if (Curry._2(p, match[0], match$1[0])) {
          return /* true */1;
        } else {
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  };
}

function zip_with(f, a, b) {
  var stop = [/* false */0];
  return (function () {
      if (stop[0]) {
        return /* None */0;
      } else {
        var match = Curry._1(a, /* () */0);
        var match$1 = Curry._1(b, /* () */0);
        if (match && match$1) {
          return /* Some */[Curry._2(f, match[0], match$1[0])];
        } else {
          stop[0] = /* true */1;
          return /* None */0;
        }
      }
    });
}

function zip(a, b) {
  return zip_with((function (x, y) {
                return /* tuple */[
                        x,
                        y
                      ];
              }), a, b);
}

var MergeState = /* module */[];

function merge(next_gen) {
  var state = /* record */[
    /* gens */Queue.create(/* () */0),
    /* state : NewGen */0
  ];
  var next = function (_param) {
    while(true) {
      var match = state[/* state */1];
      switch (match) {
        case 0 : 
            var match$1 = Curry._1(next_gen, /* () */0);
            if (match$1) {
              Queue.push(match$1[0], state[/* gens */0]);
              state[/* state */1] = /* YieldAndNew */1;
              _param = /* () */0;
              continue ;
              
            } else {
              state[/* state */1] = /* Yield */2;
              _param = /* () */0;
              continue ;
              
            }
            break;
        case 1 : 
            if (Queue.is_empty(state[/* gens */0])) {
              state[/* state */1] = /* NewGen */0;
              _param = /* () */0;
              continue ;
              
            } else {
              var gen = Queue.pop(state[/* gens */0]);
              var res = Curry._1(gen, /* () */0);
              if (res) {
                Queue.push(gen, state[/* gens */0]);
                state[/* state */1] = /* NewGen */0;
                return res;
              } else {
                state[/* state */1] = /* NewGen */0;
                _param = /* () */0;
                continue ;
                
              }
            }
            break;
        case 2 : 
            if (Queue.is_empty(state[/* gens */0])) {
              state[/* state */1] = /* Stop */3;
              return /* None */0;
            } else {
              var gen$1 = Queue.pop(state[/* gens */0]);
              var res$1 = Curry._1(gen$1, /* () */0);
              if (res$1) {
                Queue.push(gen$1, state[/* gens */0]);
                return res$1;
              } else {
                _param = /* () */0;
                continue ;
                
              }
            }
            break;
        case 3 : 
            return /* None */0;
        
      }
    };
  };
  return next;
}

function intersection($staropt$star, gen1, gen2) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var x1 = [Curry._1(gen1, /* () */0)];
  var x2 = [Curry._1(gen2, /* () */0)];
  var next = function (_param) {
    while(true) {
      var match = x1[0];
      var match$1 = x2[0];
      if (match) {
        if (match$1) {
          var y1 = match[0];
          var c = Curry._2(cmp, y1, match$1[0]);
          if (c) {
            if (c < 0) {
              x1[0] = Curry._1(gen1, /* () */0);
              _param = /* () */0;
              continue ;
              
            } else {
              x2[0] = Curry._1(gen2, /* () */0);
              _param = /* () */0;
              continue ;
              
            }
          } else {
            x1[0] = Curry._1(gen1, /* () */0);
            x2[0] = Curry._1(gen2, /* () */0);
            return /* Some */[y1];
          }
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    };
  };
  return next;
}

function sorted_merge($staropt$star, gen1, gen2) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var x1 = [Curry._1(gen1, /* () */0)];
  var x2 = [Curry._1(gen2, /* () */0)];
  return (function () {
      var match = x1[0];
      var match$1 = x2[0];
      if (match) {
        if (match$1 && Curry._2(cmp, match[0], match$1[0]) > 0) {
          x2[0] = Curry._1(gen2, /* () */0);
          return match$1;
        } else {
          x1[0] = Curry._1(gen1, /* () */0);
          return match;
        }
      } else if (match$1) {
        x2[0] = Curry._1(gen2, /* () */0);
        return match$1;
      } else {
        return /* None */0;
      }
    });
}

function empty$1(cmp) {
  return /* record */[
          /* tree : Empty */0,
          /* cmp */cmp
        ];
}

function is_empty$1(h) {
  var match = h[/* tree */0];
  if (match) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function union(cmp, t1, t2) {
  if (t1) {
    if (t2) {
      var x2 = t2[0];
      var x1 = t1[0];
      if (Curry._2(cmp, x1, x2) <= 0) {
        return /* Node */[
                x1,
                union(cmp, t2, t1[2]),
                t1[1]
              ];
      } else {
        return /* Node */[
                x2,
                union(cmp, t1, t2[2]),
                t2[1]
              ];
      }
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function insert(h, x) {
  h[/* tree */0] = union(h[/* cmp */1], /* Node */[
        x,
        /* Empty */0,
        /* Empty */0
      ], h[/* tree */0]);
  return /* () */0;
}

function pop(h) {
  var match = h[/* tree */0];
  if (match) {
    h[/* tree */0] = union(h[/* cmp */1], match[1], match[2]);
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

var Heap = /* module */[
  /* empty */empty$1,
  /* is_empty */is_empty$1,
  /* union */union,
  /* insert */insert,
  /* pop */pop
];

function sorted_merge_n($staropt$star, l) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var cmp$1 = function (param, param$1) {
    return Curry._2(cmp, param[0], param$1[0]);
  };
  var heap = /* record */[
    /* tree : Empty */0,
    /* cmp */cmp$1
  ];
  List.iter((function (gen$prime) {
          var match = Curry._1(gen$prime, /* () */0);
          if (match) {
            return insert(heap, /* tuple */[
                        match[0],
                        gen$prime
                      ]);
          } else {
            return /* () */0;
          }
        }), l);
  return (function () {
      if (is_empty$1(heap)) {
        return /* None */0;
      } else {
        var match = pop(heap);
        var gen = match[1];
        var x = match[0];
        var match$1 = Curry._1(gen, /* () */0);
        if (match$1) {
          insert(heap, /* tuple */[
                match$1[0],
                gen
              ]);
          return /* Some */[x];
        } else {
          return /* Some */[x];
        }
      }
    });
}

function round_robin($staropt$star, gen) {
  var n = $staropt$star ? $staropt$star[0] : 2;
  var qs = $$Array.init(n, (function () {
          return Queue.create(/* () */0);
        }));
  var cur = [0];
  return $$Array.to_list($$Array.mapi((function (i, _, _$1) {
                    var i$1 = i;
                    var q = Caml_array.caml_array_get(qs, i$1);
                    if (Queue.is_empty(q)) {
                      var i$2 = i$1;
                      while(true) {
                        var match = Curry._1(gen, /* () */0);
                        if (match) {
                          var x = match[0];
                          var j = cur[0];
                          cur[0] = Caml_int32.mod_(j + 1 | 0, n);
                          var q$1 = Caml_array.caml_array_get(qs, j);
                          if (j === i$2) {
                            if (!Queue.is_empty(q$1)) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "gen.ml",
                                      991,
                                      10
                                    ]
                                  ];
                            }
                            return /* Some */[x];
                          } else {
                            Queue.push(x, q$1);
                            continue ;
                            
                          }
                        } else {
                          return /* None */0;
                        }
                      };
                    } else {
                      return /* Some */[Queue.pop(q)];
                    }
                  }), qs));
}

function tee($staropt$star, gen) {
  var n = $staropt$star ? $staropt$star[0] : 2;
  var qs = $$Array.init(n, (function () {
          return Queue.create(/* () */0);
        }));
  var finished = [/* false */0];
  return $$Array.to_list($$Array.mapi((function (i, _, _$1) {
                    var i$1 = i;
                    if (Queue.is_empty(Caml_array.caml_array_get(qs, i$1))) {
                      if (finished[0]) {
                        return /* None */0;
                      } else {
                        var i$2 = i$1;
                        var res = Curry._1(gen, /* () */0);
                        if (res) {
                          for(var j = 0 ,j_finish = n - 1 | 0; j <= j_finish; ++j){
                            if (j !== i$2) {
                              Queue.push(res, Caml_array.caml_array_get(qs, j));
                            }
                            
                          }
                          return res;
                        } else {
                          finished[0] = /* true */1;
                          return /* None */0;
                        }
                      }
                    } else {
                      return Queue.pop(Caml_array.caml_array_get(qs, i$1));
                    }
                  }), qs));
}

var InterleaveState = /* module */[];

function interleave(gen_a, gen_b) {
  var state = [/* Both */Block.__(1, [
        gen_a,
        gen_b,
        [/* true */1]
      ])];
  var next = function (_param) {
    while(true) {
      var match = state[0];
      if (typeof match === "number") {
        return /* None */0;
      } else if (match.tag) {
        var r = match[2];
        var g2 = match[1];
        var g1 = match[0];
        var res = r[0] ? Curry._1(g1, /* () */0) : Curry._1(g2, /* () */0);
        if (res) {
          r[0] = 1 - r[0];
          return res;
        } else {
          state[0] = r[0] ? /* Only */Block.__(0, [g2]) : /* Only */Block.__(0, [g1]);
          _param = /* () */0;
          continue ;
          
        }
      } else {
        var res$1 = Curry._1(match[0], /* () */0);
        if (res$1) {
          return res$1;
        } else {
          state[0] = /* Stop */0;
          return /* None */0;
        }
      }
    };
  };
  return next;
}

var IntersperseState = /* module */[];

function intersperse(x, gen) {
  var state = [/* Start */0];
  var next = function (_param) {
    while(true) {
      var match = state[0];
      if (typeof match === "number") {
        if (match) {
          return /* None */0;
        } else {
          var res = Curry._1(gen, /* () */0);
          if (res) {
            state[0] = /* YieldElem */Block.__(0, [res]);
            _param = /* () */0;
            continue ;
            
          } else {
            state[0] = /* Stop */1;
            return /* None */0;
          }
        }
      } else if (match.tag) {
        state[0] = /* YieldElem */Block.__(0, [match[0]]);
        return /* Some */[x];
      } else {
        var res$prime = Curry._1(gen, /* () */0);
        if (res$prime) {
          state[0] = /* YieldSep */Block.__(1, [res$prime]);
        } else {
          state[0] = /* Stop */1;
        }
        return match[0];
      }
    };
  };
  return next;
}

function product(gena, genb) {
  var all_a = [/* [] */0];
  var all_b = [/* [] */0];
  var cur = [/* GetLeft */-410787939];
  var next = function (_param) {
    while(true) {
      var match = cur[0];
      if (typeof match === "number") {
        if (match !== -410787939) {
          if (match >= 926227490) {
            return /* None */0;
          } else {
            var match$1 = Curry._1(genb, /* () */0);
            if (match$1) {
              var b = match$1[0];
              all_b[0] = /* :: */[
                b,
                all_b[0]
              ];
              cur[0] = /* `ProdRight */[
                -470306651,
                /* tuple */[
                  b,
                  all_a[0]
                ]
              ];
            } else if (cur[0] === /* GetRightOrStop */-671547669) {
              cur[0] = /* Stop */926227490;
            } else {
              cur[0] = /* GetLeft */-410787939;
            }
            _param = /* () */0;
            continue ;
            
          }
        } else {
          var match$2 = Curry._1(gena, /* () */0);
          if (match$2) {
            var a = match$2[0];
            all_a[0] = /* :: */[
              a,
              all_a[0]
            ];
            cur[0] = /* `ProdLeft */[
              210423646,
              /* tuple */[
                a,
                all_b[0]
              ]
            ];
          } else {
            cur[0] = /* GetRightOrStop */-671547669;
          }
          _param = /* () */0;
          continue ;
          
        }
      } else if (match[0] >= 210423646) {
        var match$3 = match[1];
        var match$4 = match$3[1];
        var x = match$3[0];
        if (match$4) {
          cur[0] = /* `ProdLeft */[
            210423646,
            /* tuple */[
              x,
              match$4[1]
            ]
          ];
          return /* Some */[/* tuple */[
                    x,
                    match$4[0]
                  ]];
        } else {
          cur[0] = /* GetRight */585947014;
          _param = /* () */0;
          continue ;
          
        }
      } else {
        var match$5 = match[1];
        var match$6 = match$5[1];
        var y = match$5[0];
        if (match$6) {
          cur[0] = /* `ProdRight */[
            -470306651,
            /* tuple */[
              y,
              match$6[1]
            ]
          ];
          return /* Some */[/* tuple */[
                    match$6[0],
                    y
                  ]];
        } else {
          cur[0] = /* GetLeft */-410787939;
          _param = /* () */0;
          continue ;
          
        }
      }
    };
  };
  return next;
}

function group($staropt$star, gen) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var match = Curry._1(gen, /* () */0);
  if (match) {
    var cur = [/* :: */[
        match[0],
        /* [] */0
      ]];
    var next = function (_param) {
      while(true) {
        var next_x = cur[0] ? Curry._1(gen, /* () */0) : /* None */0;
        var match = cur[0];
        if (next_x) {
          var x = next_x[0];
          var exit = 0;
          if (match) {
            if (Curry._2(eq, x, match[0])) {
              cur[0] = /* :: */[
                x,
                cur[0]
              ];
              _param = /* () */0;
              continue ;
              
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            cur[0] = /* :: */[
              x,
              /* [] */0
            ];
            return /* Some */[match];
          }
          
        } else if (match) {
          cur[0] = /* [] */0;
          return /* Some */[match];
        } else {
          return /* None */0;
        }
      };
    };
    return next;
  } else {
    return (function () {
        return /* None */0;
      });
  }
}

function uniq($staropt$star, gen) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var state = [/* Init */0];
  var next = function (_param) {
    while(true) {
      var match = state[0];
      if (typeof match === "number") {
        if (match !== 0) {
          return /* None */0;
        } else {
          var res = Curry._1(gen, /* () */0);
          if (res) {
            state[0] = /* Run */[res[0]];
            return res;
          } else {
            state[0] = /* Stop */1;
            return /* None */0;
          }
        }
      } else {
        var res$1 = Curry._1(gen, /* () */0);
        if (res$1) {
          var y = res$1[0];
          if (Curry._2(eq, match[0], y)) {
            _param = /* () */0;
            continue ;
            
          } else {
            state[0] = /* Run */[y];
            return res$1;
          }
        } else {
          state[0] = /* Stop */1;
          return /* None */0;
        }
      }
    };
  };
  return next;
}

function sort($staropt$star, gen) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var h = /* record */[
    /* tree : Empty */0,
    /* cmp */cmp
  ];
  iter((function (param) {
          return insert(h, param);
        }), gen);
  return (function () {
      if (is_empty$1(h)) {
        return /* None */0;
      } else {
        return /* Some */[pop(h)];
      }
    });
}

function sort_uniq($staropt$star, gen) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  return uniq(/* Some */[(function (x, y) {
                  return +(Curry._2(cmp, x, y) === 0);
                })], sort(/* Some */[cmp], gen));
}

function chunks(n, e) {
  return (function () {
      var match = Curry._1(e, /* () */0);
      if (match) {
        var a = Caml_array.caml_make_vect(n, match[0]);
        var a$1 = a;
        var _i = 1;
        while(true) {
          var i = _i;
          if (i === n) {
            return /* Some */[a$1];
          } else {
            var match$1 = Curry._1(e, /* () */0);
            if (match$1) {
              Caml_array.caml_array_set(a$1, i, match$1[0]);
              _i = i + 1 | 0;
              continue ;
              
            } else {
              return /* Some */[$$Array.sub(a$1, 0, i)];
            }
          }
        };
      } else {
        return /* None */0;
      }
    });
}

var PermState = /* module */[];

function permutations(g) {
  var make_machine = function (n, l) {
    if (l) {
      var sub = make_machine(n - 1 | 0, l[1]);
      var match = next(sub, /* () */0);
      var st = match ? /* Insert */[/* record */[
            /* x */l[0],
            /* l */match[0],
            /* n */0,
            /* len */n,
            /* sub */sub
          ]] : /* Done */0;
      return /* record */[/* st */st];
    } else {
      if (n !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "gen.ml",
                1324,
                12
              ]
            ];
      }
      return /* record */[/* st : Base */1];
    }
  };
  var next = function (m, _param) {
    while(true) {
      var match = m[/* st */0];
      if (typeof match === "number") {
        if (match !== 0) {
          m[/* st */0] = /* Done */0;
          return /* Some */[/* [] */0];
        } else {
          return /* None */0;
        }
      } else {
        var state = match[0];
        var l = state[/* l */1];
        var n = state[/* n */2];
        if (n === state[/* len */3]) {
          var match$1 = next(state[/* sub */4], /* () */0);
          if (match$1) {
            state[/* l */1] = match$1[0];
            state[/* n */2] = 0;
            _param = /* () */0;
            continue ;
            
          } else {
            m[/* st */0] = /* Done */0;
            return /* None */0;
          }
        } else {
          state[/* n */2] = state[/* n */2] + 1 | 0;
          return /* Some */[insert(state[/* x */0], n, l)];
        }
      }
    };
  };
  var insert = function (x, n, l) {
    if (n !== 0) {
      if (l) {
        return /* :: */[
                l[0],
                insert(x, n - 1 | 0, l[1])
              ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "gen.ml",
                1350,
                15
              ]
            ];
      }
    } else {
      return /* :: */[
              x,
              l
            ];
    }
  };
  var l = fold((function (acc, x) {
          return /* :: */[
                  x,
                  acc
                ];
        }), /* [] */0, g);
  var partial_arg = make_machine(List.length(l), l);
  return (function (param) {
      return next(partial_arg, param);
    });
}

var HeapPermState = /* module */[];

function permutations_heap(g) {
  var l = fold((function (acc, x) {
          return /* :: */[
                  x,
                  acc
                ];
        }), /* [] */0, g);
  var a = $$Array.of_list(l);
  var n = a.length;
  if (n) {
    var partial_arg = /* record */[
      /* elts */a,
      /* n */n,
      /* is : :: */[
        0,
        /* [] */0
      ]
    ];
    return (function (param) {
        var st = partial_arg;
        var _param = param;
        while(true) {
          var n = st[/* n */1];
          if (n !== 0) {
            var match = st[/* is */2];
            if (match) {
              if (match[0] === n) {
                st[/* is */2] = match[1];
                st[/* n */1] = n + 1 | 0;
                var match$1 = st[/* is */2];
                if (match$1) {
                  var i = match$1[0];
                  var j = st[/* n */1] % 2 === 1 ? 0 : i;
                  var tmp = Caml_array.caml_array_get(st[/* elts */0], j);
                  Caml_array.caml_array_set(st[/* elts */0], j, Caml_array.caml_array_get(st[/* elts */0], n));
                  Caml_array.caml_array_set(st[/* elts */0], n, tmp);
                  st[/* is */2] = /* :: */[
                    i + 1 | 0,
                    match$1[1]
                  ];
                  _param = /* () */0;
                  continue ;
                  
                } else {
                  return /* None */0;
                }
              } else {
                st[/* n */1] = n - 1 | 0;
                st[/* is */2] = /* :: */[
                  0,
                  st[/* is */2]
                ];
                _param = /* () */0;
                continue ;
                
              }
            } else {
              return /* None */0;
            }
          } else {
            var match$2 = st[/* is */2];
            if (match$2) {
              var exit = 0;
              if (match$2[0] !== 0) {
                exit = 1;
              } else {
                var match$3 = match$2[1];
                if (match$3) {
                  st[/* is */2] = /* :: */[
                    match$3[0] + 1 | 0,
                    match$3[1]
                  ];
                  st[/* n */1] = 1;
                  return /* Some */[$$Array.copy(a)];
                } else {
                  exit = 1;
                }
              }
              if (exit === 1) {
                if (match$2[1]) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "gen.ml",
                          1413,
                          23
                        ]
                      ];
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "gen.ml",
                          1408,
                          26
                        ]
                      ];
                }
              }
              
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "gen.ml",
                      1408,
                      26
                    ]
                  ];
            }
          }
        };
      });
  } else {
    return empty;
  }
}

var CombState = /* module */[];

function combinations(n, g) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            1460,
            2
          ]
        ];
  }
  var make_state = function (n, l) {
    if (n !== 0) {
      if (l) {
        var tail = l[1];
        var m1 = make_state(n - 1 | 0, tail);
        var m2 = make_state(n, tail);
        return /* record */[/* st : Add */Block.__(0, [
                    l[0],
                    m1,
                    m2
                  ])];
      } else {
        return /* record */[/* st : Done */0];
      }
    } else {
      return /* record */[/* st : Base */1];
    }
  };
  var next = function (m, _param) {
    while(true) {
      var match = m[/* st */0];
      if (typeof match === "number") {
        if (match) {
          m[/* st */0] = /* Done */0;
          return /* Some */[/* [] */0];
        } else {
          return /* None */0;
        }
      } else if (match.tag) {
        var m$1 = match[0];
        var res = next(m$1, /* () */0);
        if (res) {
          return res;
        } else {
          m$1[/* st */0] = /* Done */0;
          return /* None */0;
        }
      } else {
        var match$1 = next(match[1], /* () */0);
        if (match$1) {
          return /* Some */[/* :: */[
                    match[0],
                    match$1[0]
                  ]];
        } else {
          m[/* st */0] = /* Follow */Block.__(1, [match[2]]);
          _param = /* () */0;
          continue ;
          
        }
      }
    };
  };
  var l = fold((function (acc, x) {
          return /* :: */[
                  x,
                  acc
                ];
        }), /* [] */0, g);
  var partial_arg = make_state(n, l);
  return (function (param) {
      return next(partial_arg, param);
    });
}

var PowerSetState = /* module */[];

function power_set(g) {
  var make_state = function (l) {
    if (l) {
      var m = make_state(l[1]);
      return /* record */[/* st : Add */Block.__(0, [
                  l[0],
                  m
                ])];
    } else {
      return /* record */[/* st : Base */1];
    }
  };
  var next = function (m, _) {
    var match = m[/* st */0];
    if (typeof match === "number") {
      if (match) {
        m[/* st */0] = /* Done */0;
        return /* Some */[/* [] */0];
      } else {
        return /* None */0;
      }
    } else if (match.tag) {
      var x = match[1];
      m[/* st */0] = /* Add */Block.__(0, [
          x,
          match[2]
        ]);
      return /* Some */[/* :: */[
                x,
                match[0]
              ]];
    } else {
      var m$prime = match[1];
      var res = next(m$prime, /* () */0);
      if (res) {
        m[/* st */0] = /* AddTo */Block.__(1, [
            res[0],
            match[0],
            m$prime
          ]);
        return res;
      } else {
        m[/* st */0] = /* Done */0;
        return /* None */0;
      }
    }
  };
  var l = fold((function (acc, x) {
          return /* :: */[
                  x,
                  acc
                ];
        }), /* [] */0, g);
  var partial_arg = make_state(l);
  return (function (param) {
      return next(partial_arg, param);
    });
}

function of_list(l) {
  var l$1 = [l];
  return (function () {
      var match = l$1[0];
      if (match) {
        l$1[0] = match[1];
        return /* Some */[match[0]];
      } else {
        return /* None */0;
      }
    });
}

function to_rev_list(gen) {
  return fold((function (acc, x) {
                return /* :: */[
                        x,
                        acc
                      ];
              }), /* [] */0, gen);
}

function to_list(gen) {
  return List.rev(to_rev_list(gen));
}

function to_array(gen) {
  var l = to_rev_list(gen);
  if (l) {
    var a = $$Array.of_list(l);
    var n = a.length;
    for(var i = 0 ,i_finish = (n - 1 | 0) / 2 | 0; i <= i_finish; ++i){
      var tmp = Caml_array.caml_array_get(a, i);
      Caml_array.caml_array_set(a, i, Caml_array.caml_array_get(a, (n - i | 0) - 1 | 0));
      Caml_array.caml_array_set(a, (n - i | 0) - 1 | 0, tmp);
    }
    return a;
  } else {
    return /* array */[];
  }
}

function of_array($staropt$star, len, a) {
  var start = $staropt$star ? $staropt$star[0] : 0;
  var len$1;
  if (len) {
    var n = len[0];
    if ((n + start | 0) >= a.length) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "gen.ml",
              1573,
              16
            ]
          ];
    }
    len$1 = n;
  } else {
    len$1 = a.length - start | 0;
  }
  var i = [start];
  return (function () {
      if (i[0] >= (start + len$1 | 0)) {
        return /* None */0;
      } else {
        var x = Caml_array.caml_array_get(a, i[0]);
        i[0] = i[0] + 1 | 0;
        return /* Some */[x];
      }
    });
}

function of_string($staropt$star, len, s) {
  var start = $staropt$star ? $staropt$star[0] : 0;
  var len$1;
  if (len) {
    var n = len[0];
    if ((n + start | 0) >= s.length) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "gen.ml",
              1588,
              16
            ]
          ];
    }
    len$1 = n;
  } else {
    len$1 = s.length - start | 0;
  }
  var i = [start];
  return (function () {
      if (i[0] >= (start + len$1 | 0)) {
        return /* None */0;
      } else {
        var x = Caml_string.get(s, i[0]);
        i[0] = i[0] + 1 | 0;
        return /* Some */[x];
      }
    });
}

function to_buffer(buf, g) {
  return iter((function (param) {
                return Buffer.add_char(buf, param);
              }), g);
}

function to_string(s) {
  var buf = Buffer.create(16);
  iter((function (param) {
          return Buffer.add_char(buf, param);
        }), s);
  return Buffer.contents(buf);
}

function rand_int(i) {
  return (function () {
      return /* Some */[Random.$$int(i)];
    });
}

function int_range($staropt$star, i, j) {
  var step = $staropt$star ? $staropt$star[0] : 1;
  if (!step) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Gen.int_range"
        ];
  }
  var $great = step > 0 ? Caml_obj.caml_greaterthan : Caml_obj.caml_lessthan;
  var r = [i];
  return (function () {
      var x = r[0];
      if (Curry._2($great, x, j)) {
        return /* None */0;
      } else {
        r[0] = r[0] + step | 0;
        return /* Some */[x];
      }
    });
}

function lines(g) {
  var buf = Buffer.create(32);
  var stop = [/* false */0];
  var next = function (_param) {
    while(true) {
      if (stop[0]) {
        return /* None */0;
      } else {
        var match = Curry._1(g, /* () */0);
        if (match) {
          var c = match[0];
          if (c !== 10) {
            Buffer.add_char(buf, c);
            _param = /* () */0;
            continue ;
            
          } else {
            var s = Buffer.contents(buf);
            Buffer.clear(buf);
            return /* Some */[s];
          }
        } else {
          stop[0] = /* true */1;
          if (Buffer.length(buf)) {
            return /* Some */[Buffer.contents(buf)];
          } else {
            return /* None */0;
          }
        }
      }
    };
  };
  return next;
}

function unlines(g) {
  var st = [/* Next */870035731];
  return (function () {
      var match = st[0];
      if (typeof match === "number") {
        if (match >= 926227490) {
          return /* None */0;
        } else {
          var match$1 = Curry._1(g, /* () */0);
          if (match$1) {
            var s = match$1[0];
            if (s === "") {
              return /* Some */[/* "\n" */10];
            } else {
              st[0] = /* `Consume */[
                -433348196,
                /* tuple */[
                  s,
                  1
                ]
              ];
              return /* Some */[Caml_string.get(s, 0)];
            }
          } else {
            st[0] = /* Stop */926227490;
            return /* None */0;
          }
        }
      } else {
        var match$2 = match[1];
        var i = match$2[1];
        var s$1 = match$2[0];
        if (i === s$1.length) {
          st[0] = /* Next */870035731;
          return /* Some */[/* "\n" */10];
        } else {
          st[0] = /* `Consume */[
            -433348196,
            /* tuple */[
              s$1,
              i + 1 | 0
            ]
          ];
          return /* Some */[Caml_string.get(s$1, i)];
        }
      }
    });
}

function pp($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, pp_elem, formatter, gen) {
  var start = $staropt$star ? $staropt$star[0] : "";
  var stop = $staropt$star$1 ? $staropt$star$1[0] : "";
  var sep = $staropt$star$2 ? $staropt$star$2[0] : ",";
  var horizontal = $staropt$star$3 ? $staropt$star$3[0] : /* false */0;
  if (horizontal) {
    Format.pp_open_hbox(formatter, /* () */0);
  } else {
    Format.pp_open_hvbox(formatter, 0);
  }
  Format.pp_print_string(formatter, start);
  var next = function (_is_first) {
    while(true) {
      var is_first = _is_first;
      var match = Curry._1(gen, /* () */0);
      if (match) {
        var x = match[0];
        if (is_first) {
          Curry._2(pp_elem, formatter, x);
        } else {
          Format.pp_print_string(formatter, sep);
          Format.pp_print_space(formatter, /* () */0);
          Curry._2(pp_elem, formatter, x);
        }
        _is_first = /* false */0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  next(/* true */1);
  Format.pp_print_string(formatter, stop);
  return Format.pp_close_box(formatter, /* () */0);
}

var partial_arg = /* Some */[1];

function $neg$neg(param, param$1) {
  return int_range(partial_arg, param, param$1);
}

function $great$great$eq(x, f) {
  return flat_map(f, x);
}

function $great$great$pipe(x, f) {
  return map(f, x);
}

function $great$pipe$eq(x, f) {
  return map(f, x);
}

var Infix = /* module */[
  /* -- */$neg$neg,
  /* >>= */$great$great$eq,
  /* >>| */$great$great$pipe,
  /* >|= */$great$pipe$eq
];

function lift(f, e) {
  return Curry._1(f, Curry._1(e, /* () */0));
}

function lift2(f, e1, e2) {
  return Curry._2(f, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function empty$2() {
  return empty;
}

function singleton$1(x, _) {
  return singleton(x);
}

function iterate$1(x, f, _) {
  return iterate(x, f);
}

function repeat$1(x, _) {
  return (function () {
      return /* Some */[x];
    });
}

function unfold$1(f, acc, _) {
  return unfold(f, acc);
}

function init$1(limit, f, _) {
  return init(limit, f);
}

function cycle($$enum) {
  if (is_empty(Curry._1($$enum, /* () */0))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "gen.ml",
            1721,
            4
          ]
        ];
  }
  return (function () {
      var gen = [Curry._1($$enum, /* () */0)];
      var next = function (_param) {
        while(true) {
          var res = Curry._1(gen[0], /* () */0);
          if (res) {
            return res;
          } else {
            gen[0] = Curry._1($$enum, /* () */0);
            _param = /* () */0;
            continue ;
            
          }
        };
      };
      return next;
    });
}

function is_empty$2(e) {
  return is_empty(Curry._1(e, /* () */0));
}

function fold$1(f, acc, e) {
  return fold(f, acc, Curry._1(e, /* () */0));
}

function reduce$1(f, e) {
  return reduce(f, Curry._1(e, /* () */0));
}

function scan$1(f, acc, e, _) {
  return scan(f, acc, Curry._1(e, /* () */0));
}

function unfold_scan$1(f, acc, e, _) {
  return unfold_scan(f, acc, Curry._1(e, /* () */0));
}

function iter$1(f, e) {
  return iter(f, Curry._1(e, /* () */0));
}

function iteri$1(f, e) {
  return iteri(f, Curry._1(e, /* () */0));
}

function length$1(e) {
  return length(Curry._1(e, /* () */0));
}

function map$1(f, e, _) {
  return map(f, Curry._1(e, /* () */0));
}

function mapi$1(f, e, _) {
  return mapi(f)(Curry._1(e, /* () */0));
}

function fold_map$1(f, s, e, _) {
  return fold_map(f, s, Curry._1(e, /* () */0));
}

function append$1(e1, e2, _) {
  return append(Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function flatten$1(e, _) {
  return flatten(Curry._1(e, /* () */0));
}

function flat_map$1(f, e, _) {
  return flat_map(f, Curry._1(e, /* () */0));
}

function mem$1(eq, x, e) {
  return mem(eq, x, Curry._1(e, /* () */0));
}

function take$1(n, e, _) {
  return take(n, Curry._1(e, /* () */0));
}

function drop$1(n, e, _) {
  return drop(n, Curry._1(e, /* () */0));
}

function nth$1(n, e) {
  return nth(n, Curry._1(e, /* () */0));
}

function take_nth$1(n, e, _) {
  return take_nth(n, Curry._1(e, /* () */0));
}

function filter$1(p, e, _) {
  return filter(p, Curry._1(e, /* () */0));
}

function take_while$1(p, e, _) {
  return take_while(p, Curry._1(e, /* () */0));
}

function fold_while$1(f, s, e) {
  return fold_while(f, s, Curry._1(e, /* () */0));
}

function drop_while$1(p, e, _) {
  return drop_while(p, Curry._1(e, /* () */0));
}

function filter_map$1(f, e, _) {
  return filter_map(f, Curry._1(e, /* () */0));
}

function zip_with$1(f, e1, e2, _) {
  return zip_with(f, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function zip$1(e1, e2, _) {
  return zip(Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function zip_index$1(e, _) {
  return zip_index(Curry._1(e, /* () */0));
}

function unzip$1(e) {
  return /* tuple */[
          (function () {
              return map((function (prim) {
                            return prim[0];
                          }), Curry._1(e, /* () */0));
            }),
          (function () {
              return map((function (prim) {
                            return prim[1];
                          }), Curry._1(e, /* () */0));
            })
        ];
}

function partition$1(p, e) {
  return /* tuple */[
          (function () {
              return filter(p, Curry._1(e, /* () */0));
            }),
          (function () {
              return filter((function (x) {
                            return 1 - Curry._1(p, x);
                          }), Curry._1(e, /* () */0));
            })
        ];
}

function for_all$1(p, e) {
  return for_all(p, Curry._1(e, /* () */0));
}

function exists$1(p, e) {
  return exists(p, Curry._1(e, /* () */0));
}

function for_all2$1(p, e1, e2) {
  return for_all2(p, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function exists2$1(p, e1, e2) {
  return exists2(p, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function map2$1(f, e1, e2, _) {
  var partial_arg = Curry._1(e2, /* () */0);
  var partial_arg$1 = Curry._1(e1, /* () */0);
  return (function (param) {
      return map2(f, partial_arg$1, partial_arg, param);
    });
}

function iter2$1(f, e1, e2) {
  return iter2(f, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function fold2$1(f, acc, e1, e2) {
  return fold2(f, acc, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function min$1(lt, e) {
  return min(lt, Curry._1(e, /* () */0));
}

function max$1(lt, e) {
  return max(lt, Curry._1(e, /* () */0));
}

function eq$1(eq$2, e1, e2) {
  return eq(eq$2, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function lexico$1(cmp, e1, e2) {
  return lexico(cmp, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function compare$1(cmp, e1, e2) {
  return lexico(cmp, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function sum$1(e) {
  return sum(Curry._1(e, /* () */0));
}

function find$1(f, e) {
  return find(f, Curry._1(e, /* () */0));
}

function merge$1(e, _) {
  return merge(Curry._1(e, /* () */0));
}

function intersection$1(cmp, e1, e2, _) {
  return intersection(cmp, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function sorted_merge$1(cmp, e1, e2, _) {
  return sorted_merge(cmp, Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function sorted_merge_n$1(cmp, l, _) {
  return sorted_merge_n(cmp, List.map((function (g) {
                    return Curry._1(g, /* () */0);
                  }), l));
}

function tee$1(n, e) {
  return tee(n, Curry._1(e, /* () */0));
}

function round_robin$1(n, e) {
  return round_robin(n, Curry._1(e, /* () */0));
}

function interleave$1(e1, e2, _) {
  return interleave(Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function intersperse$1(x, e, _) {
  return intersperse(x, Curry._1(e, /* () */0));
}

function product$1(e1, e2, _) {
  return product(Curry._1(e1, /* () */0), Curry._1(e2, /* () */0));
}

function group$1(eq, e, _) {
  return group(eq, Curry._1(e, /* () */0));
}

function uniq$1(eq, e, _) {
  return uniq(eq, Curry._1(e, /* () */0));
}

function sort$1($staropt$star, $$enum, _) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  return sort(/* Some */[cmp], Curry._1($$enum, /* () */0));
}

function sort_uniq$1($staropt$star, e) {
  var cmp = $staropt$star ? $staropt$star[0] : Caml_obj.caml_compare;
  var partial_arg = /* Some */[cmp];
  var e$prime = function (param) {
    return sort$1(partial_arg, e, param);
  };
  var partial_arg$1 = /* Some */[(function (x, y) {
        return +(Curry._2(cmp, x, y) === 0);
      })];
  return (function () {
      return uniq(partial_arg$1, Curry._1(e$prime, /* () */0));
    });
}

function chunks$1(n, e, _) {
  return chunks(n, Curry._1(e, /* () */0));
}

function permutations$1(g, _) {
  return permutations(Curry._1(g, /* () */0));
}

function permutations_heap$1(g, _) {
  return permutations_heap(Curry._1(g, /* () */0));
}

function combinations$1(n, g, _) {
  return combinations(n, Curry._1(g, /* () */0));
}

function power_set$1(g, _) {
  return power_set(Curry._1(g, /* () */0));
}

function of_list$1(l, _) {
  return of_list(l);
}

function to_rev_list$1(e) {
  return to_rev_list(Curry._1(e, /* () */0));
}

function to_list$1(e) {
  var gen = Curry._1(e, /* () */0);
  return List.rev(to_rev_list(gen));
}

function to_array$1(e) {
  return to_array(Curry._1(e, /* () */0));
}

function of_array$1(start, len, a, _) {
  return of_array(start, len, a);
}

function of_string$1(start, len, s, _) {
  return of_string(start, len, s);
}

function to_string$1(s) {
  return to_string(Curry._1(s, /* () */0));
}

function to_buffer$1(buf, s) {
  var g = Curry._1(s, /* () */0);
  return iter((function (param) {
                return Buffer.add_char(buf, param);
              }), g);
}

function rand_int$1(i, _) {
  return (function () {
      return /* Some */[Random.$$int(i)];
    });
}

function int_range$1(step, i, j, _) {
  return int_range(step, i, j);
}

function lines$1(g, _) {
  return lines(Curry._1(g, /* () */0));
}

function unlines$1(g, _) {
  return unlines(Curry._1(g, /* () */0));
}

var partial_arg$1 = /* Some */[1];

function $neg$neg$1(param, param$1, _) {
  return int_range(partial_arg$1, param, param$1);
}

function $great$great$eq$1(x, f) {
  return (function () {
      return flat_map(f, Curry._1(x, /* () */0));
    });
}

function $great$great$pipe$1(x, f) {
  return (function () {
      return map(f, Curry._1(x, /* () */0));
    });
}

function $great$pipe$eq$1(x, f) {
  return (function () {
      return map(f, Curry._1(x, /* () */0));
    });
}

var Infix$1 = /* module */[
  /* -- */$neg$neg$1,
  /* >>= */$great$great$eq$1,
  /* >>| */$great$great$pipe$1,
  /* >|= */$great$pipe$eq$1
];

function pp$1(start, stop, sep, horizontal, pp_elem, fmt, e) {
  return pp(start, stop, sep, horizontal, pp_elem, fmt, Curry._1(e, /* () */0));
}

function of_gen(caching, max_chunk_size, g) {
  var cached = [/* None */0];
  return (function () {
      var match = cached[0];
      if (match) {
        return GenMList$ReasonmlDemoIterators.to_gen(match[0]);
      } else {
        var mlist = GenMList$ReasonmlDemoIterators.of_gen_lazy(max_chunk_size, caching, g);
        cached[0] = /* Some */[mlist];
        return GenMList$ReasonmlDemoIterators.to_gen(mlist);
      }
    });
}

var Restart = /* module */[
  /* lift */lift,
  /* lift2 */lift2,
  /* empty */empty$2,
  /* singleton */singleton$1,
  /* return */singleton$1,
  /* iterate */iterate$1,
  /* repeat */repeat$1,
  /* unfold */unfold$1,
  /* init */init$1,
  /* cycle */cycle,
  /* is_empty */is_empty$2,
  /* fold */fold$1,
  /* reduce */reduce$1,
  /* scan */scan$1,
  /* unfold_scan */unfold_scan$1,
  /* iter */iter$1,
  /* iteri */iteri$1,
  /* length */length$1,
  /* map */map$1,
  /* mapi */mapi$1,
  /* fold_map */fold_map$1,
  /* append */append$1,
  /* flatten */flatten$1,
  /* flat_map */flat_map$1,
  /* mem */mem$1,
  /* take */take$1,
  /* drop */drop$1,
  /* nth */nth$1,
  /* take_nth */take_nth$1,
  /* filter */filter$1,
  /* take_while */take_while$1,
  /* fold_while */fold_while$1,
  /* drop_while */drop_while$1,
  /* filter_map */filter_map$1,
  /* zip_with */zip_with$1,
  /* zip */zip$1,
  /* zip_index */zip_index$1,
  /* unzip */unzip$1,
  /* partition */partition$1,
  /* for_all */for_all$1,
  /* exists */exists$1,
  /* for_all2 */for_all2$1,
  /* exists2 */exists2$1,
  /* map2 */map2$1,
  /* iter2 */iter2$1,
  /* fold2 */fold2$1,
  /* min */min$1,
  /* max */max$1,
  /* ___eq */eq,
  /* eq */eq$1,
  /* lexico */lexico$1,
  /* compare */compare$1,
  /* sum */sum$1,
  /* find */find$1,
  /* merge */merge$1,
  /* intersection */intersection$1,
  /* sorted_merge */sorted_merge$1,
  /* sorted_merge_n */sorted_merge_n$1,
  /* tee */tee$1,
  /* round_robin */round_robin$1,
  /* interleave */interleave$1,
  /* intersperse */intersperse$1,
  /* product */product$1,
  /* group */group$1,
  /* uniq */uniq$1,
  /* sort */sort$1,
  /* sort_uniq */sort_uniq$1,
  /* chunks */chunks$1,
  /* permutations */permutations$1,
  /* permutations_heap */permutations_heap$1,
  /* combinations */combinations$1,
  /* power_set */power_set$1,
  /* of_list */of_list$1,
  /* to_rev_list */to_rev_list$1,
  /* to_list */to_list$1,
  /* to_array */to_array$1,
  /* of_array */of_array$1,
  /* of_string */of_string$1,
  /* to_string */to_string$1,
  /* to_buffer */to_buffer$1,
  /* rand_int */rand_int$1,
  /* int_range */int_range$1,
  /* lines */lines$1,
  /* unlines */unlines$1,
  /* Infix */Infix$1,
  /* -- */$neg$neg$1,
  /* >>= */$great$great$eq$1,
  /* >>| */$great$great$pipe$1,
  /* >|= */$great$pipe$eq$1,
  /* pp */pp$1,
  /* of_gen */of_gen
];

function start(g) {
  return Curry._1(g, /* () */0);
}

function persistent(gen) {
  var l = GenMList$ReasonmlDemoIterators.of_gen(gen);
  return (function () {
      return GenMList$ReasonmlDemoIterators.to_gen(l);
    });
}

function persistent_lazy(caching, max_chunk_size, gen) {
  var l = GenMList$ReasonmlDemoIterators.of_gen_lazy(max_chunk_size, caching, gen);
  return (function () {
      return GenMList$ReasonmlDemoIterators.to_gen(l);
    });
}

function peek(g) {
  var state = [/* Start */389604418];
  var next = function (_param) {
    while(true) {
      var match = state[0];
      if (typeof match === "number") {
        if (match >= 926227490) {
          return /* None */0;
        } else {
          var match$1 = Curry._1(g, /* () */0);
          if (match$1) {
            state[0] = /* `At */[
              14611,
              match$1[0]
            ];
            _param = /* () */0;
            continue ;
            
          } else {
            state[0] = /* Stop */926227490;
            return /* None */0;
          }
        }
      } else {
        var x = match[1];
        var res = Curry._1(g, /* () */0);
        if (res) {
          state[0] = /* `At */[
            14611,
            res[0]
          ];
          return /* Some */[/* tuple */[
                    x,
                    res
                  ]];
        } else {
          state[0] = /* Stop */926227490;
          return /* Some */[/* tuple */[
                    x,
                    /* None */0
                  ]];
        }
      }
    };
  };
  return next;
}

function queue_to_array_(q) {
  if (Queue.is_empty(q)) {
    return /* array */[];
  } else {
    var x = Queue.peek(q);
    var a = Caml_array.caml_make_vect(Queue.length(q), x);
    var i = [0];
    Queue.iter((function (x) {
            Caml_array.caml_array_set(a, i[0], x);
            i[0] = i[0] + 1 | 0;
            return /* () */0;
          }), q);
    return a;
  }
}

function peek_n(n, g) {
  if (n < 1) {
    Pervasives.invalid_arg("peek_n");
  }
  var state = [/* Start */389604418];
  var q = Queue.create(/* () */0);
  var next = function (_param) {
    while(true) {
      var match = state[0];
      if (match !== 389604418) {
        if (match >= 926227490) {
          return /* None */0;
        } else {
          if (Queue.is_empty(q)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "gen.ml",
                    1999,
                    8
                  ]
                ];
          }
          var x = Queue.pop(q);
          fill(1);
          state[0] = Queue.is_empty(q) ? /* Stop */926227490 : /* Continue */192584839;
          return /* Some */[/* tuple */[
                    x,
                    queue_to_array_(q)
                  ]];
        }
      } else {
        fill(n);
        state[0] = Queue.is_empty(q) ? /* Stop */926227490 : /* Continue */192584839;
        _param = /* () */0;
        continue ;
        
      }
    };
  };
  var fill = function (_i) {
    while(true) {
      var i = _i;
      if ((i + Queue.length(q) | 0) > n) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "gen.ml",
                2007,
                4
              ]
            ];
      }
      if (i > 0) {
        var match = Curry._1(g, /* () */0);
        if (match) {
          Queue.push(match[0], q);
          _i = i - 1 | 0;
          continue ;
          
        } else {
          return /* () */0;
        }
      } else {
        return 0;
      }
    };
  };
  return next;
}

function with_file_in($staropt$star, $staropt$star$1, filename, f) {
  var mode = $staropt$star ? $staropt$star[0] : 420;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, ic);
    Pervasives.close_in_noerr(ic);
    return x;
  }
  catch (e){
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function with_in(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, (function () {
                              try {
                                return /* Some */[Pervasives.input_char(ic)];
                              }
                              catch (exn){
                                if (exn === Caml_builtin_exceptions.end_of_file) {
                                  return /* None */0;
                                } else {
                                  throw exn;
                                }
                              }
                            }));
              }));
}

function with_lines(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, (function () {
                              try {
                                return /* Some */[Pervasives.input_line(ic)];
                              }
                              catch (exn){
                                if (exn === Caml_builtin_exceptions.end_of_file) {
                                  return /* None */0;
                                } else {
                                  throw exn;
                                }
                              }
                            }));
              }));
}

function with_file_out($staropt$star, $staropt$star$1, filename, f) {
  var mode = $staropt$star ? $staropt$star[0] : 420;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : /* :: */[
      /* Open_creat */3,
      /* :: */[
        /* Open_wronly */1,
        /* [] */0
      ]
    ];
  var oc = Pervasives.open_out_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, oc);
    Pervasives.close_out(oc);
    return x;
  }
  catch (e){
    Pervasives.close_out_noerr(oc);
    throw e;
  }
}

function write_str(mode, flags, $staropt$star, filename, g) {
  var sep = $staropt$star ? $staropt$star[0] : "";
  return with_file_out(mode, flags, filename, (function (oc) {
                return iteri((function (i, s) {
                              if (i > 0) {
                                Pervasives.output_string(oc, sep);
                              }
                              return Pervasives.output_string(oc, s);
                            }), g);
              }));
}

function write(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (c) {
                              return Pervasives.output_char(oc, c);
                            }), g);
              }));
}

function write_lines(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (s) {
                              Pervasives.output_string(oc, s);
                              return Pervasives.output_char(oc, /* "\n" */10);
                            }), g);
              }));
}

var IO = /* module */[
  /* with_file_in */with_file_in,
  /* with_in */with_in,
  /* with_lines */with_lines,
  /* with_file_out */with_file_out,
  /* write_str */write_str,
  /* write */write,
  /* write_lines */write_lines
];

var $$return = singleton;

exports.empty             = empty;
exports.singleton         = singleton;
exports.$$return          = $$return;
exports.repeat            = repeat;
exports.repeatedly        = repeatedly;
exports.iterate           = iterate;
exports.next              = next;
exports.get               = get;
exports.get_exn           = get_exn;
exports.junk              = junk;
exports.fold              = fold;
exports.reduce            = reduce;
exports.unfold            = unfold;
exports.init              = init;
exports.iter              = iter;
exports.iteri             = iteri;
exports.is_empty          = is_empty;
exports.length            = length;
exports.RunState          = RunState;
exports.scan              = scan;
exports.unfold_scan       = unfold_scan;
exports.map               = map;
exports.mapi              = mapi;
exports.fold_map          = fold_map;
exports.append            = append;
exports.flatten           = flatten;
exports.flat_map          = flat_map;
exports.mem               = mem;
exports.take              = take;
exports.__drop            = __drop;
exports.drop              = drop;
exports.nth               = nth;
exports.take_nth          = take_nth;
exports.filter            = filter;
exports.take_while        = take_while;
exports.fold_while        = fold_while;
exports.DropWhileState    = DropWhileState;
exports.drop_while        = drop_while;
exports.filter_map        = filter_map;
exports.zip_index         = zip_index;
exports.unzip             = unzip;
exports.partition         = partition;
exports.for_all           = for_all;
exports.exists            = exists;
exports.min               = min;
exports.max               = max;
exports.eq                = eq;
exports.lexico            = lexico;
exports.compare           = compare;
exports.find              = find;
exports.sum               = sum;
exports.map2              = map2;
exports.iter2             = iter2;
exports.fold2             = fold2;
exports.for_all2          = for_all2;
exports.exists2           = exists2;
exports.zip_with          = zip_with;
exports.zip               = zip;
exports.MergeState        = MergeState;
exports.merge             = merge;
exports.intersection      = intersection;
exports.sorted_merge      = sorted_merge;
exports.Heap              = Heap;
exports.sorted_merge_n    = sorted_merge_n;
exports.round_robin       = round_robin;
exports.tee               = tee;
exports.InterleaveState   = InterleaveState;
exports.interleave        = interleave;
exports.IntersperseState  = IntersperseState;
exports.intersperse       = intersperse;
exports.product           = product;
exports.group             = group;
exports.uniq              = uniq;
exports.sort              = sort;
exports.sort_uniq         = sort_uniq;
exports.chunks            = chunks;
exports.PermState         = PermState;
exports.permutations      = permutations;
exports.HeapPermState     = HeapPermState;
exports.permutations_heap = permutations_heap;
exports.CombState         = CombState;
exports.combinations      = combinations;
exports.PowerSetState     = PowerSetState;
exports.power_set         = power_set;
exports.of_list           = of_list;
exports.to_rev_list       = to_rev_list;
exports.to_list           = to_list;
exports.to_array          = to_array;
exports.of_array          = of_array;
exports.of_string         = of_string;
exports.to_buffer         = to_buffer;
exports.to_string         = to_string;
exports.rand_int          = rand_int;
exports.int_range         = int_range;
exports.lines             = lines;
exports.unlines           = unlines;
exports.pp                = pp;
exports.Infix             = Infix;
exports.$neg$neg          = $neg$neg;
exports.$great$great$eq   = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.$great$pipe$eq    = $great$pipe$eq;
exports.Restart           = Restart;
exports.start             = start;
exports.persistent        = persistent;
exports.persistent_lazy   = persistent_lazy;
exports.peek              = peek;
exports.queue_to_array_   = queue_to_array_;
exports.peek_n            = peek_n;
exports.IO                = IO;
/* Format Not a pure module */
