// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var GenMList$ReasonmlDemoIterators = require("./genMList.bs.js");

function empty(param) {
  
}

function singleton(x) {
  var first = {
    contents: true
  };
  return function (param) {
    if (first.contents) {
      first.contents = false;
      return Caml_option.some(x);
    }
    
  };
}

function repeat(x, param) {
  return Caml_option.some(x);
}

function repeatedly(f, param) {
  return Caml_option.some(Curry._1(f, undefined));
}

function iterate(x, f) {
  var cur = {
    contents: x
  };
  return function (param) {
    var x = cur.contents;
    cur.contents = Curry._1(f, cur.contents);
    return Caml_option.some(x);
  };
}

function next(gen) {
  return Curry._1(gen, undefined);
}

function get(gen) {
  return Curry._1(gen, undefined);
}

function get_exn(gen) {
  var x = Curry._1(gen, undefined);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Gen.get_exn",
        Error: new Error()
      };
}

function junk(gen) {
  Curry._1(gen, undefined);
  
}

function fold(f, _acc, gen) {
  while(true) {
    var acc = _acc;
    var x = Curry._1(gen, undefined);
    if (x === undefined) {
      return acc;
    }
    _acc = Curry._2(f, acc, Caml_option.valFromOption(x));
    continue ;
  };
}

function reduce(f, g) {
  var x = Curry._1(g, undefined);
  var acc;
  if (x !== undefined) {
    acc = Caml_option.valFromOption(x);
  } else {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "reduce",
          Error: new Error()
        };
  }
  return fold(f, acc, g);
}

function unfold(f, acc) {
  var acc$1 = {
    contents: acc
  };
  return function (param) {
    var match = Curry._1(f, acc$1.contents);
    if (match !== undefined) {
      acc$1.contents = match[1];
      return Caml_option.some(match[0]);
    }
    
  };
}

function init(limitOpt, f) {
  var limit = limitOpt !== undefined ? limitOpt : Pervasives.max_int;
  var r = {
    contents: 0
  };
  return function (param) {
    if (r.contents >= limit) {
      return ;
    }
    var x = Curry._1(f, r.contents);
    r.contents = r.contents + 1 | 0;
    return Caml_option.some(x);
  };
}

function iter(f, gen) {
  while(true) {
    var x = Curry._1(gen, undefined);
    if (x === undefined) {
      return ;
    }
    Curry._1(f, Caml_option.valFromOption(x));
    continue ;
  };
}

function iteri(f, gen) {
  var _i = 0;
  while(true) {
    var i = _i;
    var x = Curry._1(gen, undefined);
    if (x === undefined) {
      return ;
    }
    Curry._2(f, i, Caml_option.valFromOption(x));
    _i = i + 1 | 0;
    continue ;
  };
}

function is_empty(gen) {
  var match = Curry._1(gen, undefined);
  return match === undefined;
}

function length(gen) {
  return fold((function (acc, param) {
                return acc + 1 | 0;
              }), 0, gen);
}

var RunState = {};

function scan(f, acc, g) {
  var state = {
    contents: /* Init */0
  };
  return function (param) {
    var acc$1 = state.contents;
    if (typeof acc$1 === "number") {
      if (acc$1 !== 0) {
        return ;
      } else {
        state.contents = /* Run */{
          _0: acc
        };
        return Caml_option.some(acc);
      }
    }
    var x = Curry._1(g, undefined);
    if (x !== undefined) {
      var acc$prime = Curry._2(f, acc$1._0, Caml_option.valFromOption(x));
      state.contents = /* Run */{
        _0: acc$prime
      };
      return Caml_option.some(acc$prime);
    }
    state.contents = /* Stop */1;
    
  };
}

function unfold_scan(f, acc, g) {
  var state = {
    contents: /* Run */{
      _0: acc
    }
  };
  return function (param) {
    var acc = state.contents;
    if (typeof acc === "number") {
      if (acc !== 0) {
        return ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "gen.re",
              257,
              14
            ],
            Error: new Error()
          };
    }
    var x = Curry._1(g, undefined);
    if (x !== undefined) {
      var match = Curry._2(f, acc._0, Caml_option.valFromOption(x));
      state.contents = /* Run */{
        _0: match[0]
      };
      return Caml_option.some(match[1]);
    }
    state.contents = /* Stop */1;
    
  };
}

function map(f, gen) {
  var stop = {
    contents: false
  };
  return function (param) {
    if (stop.contents) {
      return ;
    }
    var x = Curry._1(gen, undefined);
    if (x !== undefined) {
      return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
    } else {
      stop.contents = true;
      return ;
    }
  };
}

function mapi(f) {
  var cnt = {
    contents: 0
  };
  return function (param) {
    return map((function (x) {
                  var i = cnt.contents;
                  cnt.contents = i + 1 | 0;
                  return Curry._2(f, i, x);
                }), param);
  };
}

function fold_map(f, s, gen) {
  var state = {
    contents: s
  };
  return map((function (x) {
                state.contents = Curry._2(f, state.contents, x);
                return state.contents;
              }), gen);
}

function append(gen1, gen2) {
  var first = {
    contents: true
  };
  return function (param) {
    if (!first.contents) {
      return Curry._1(gen2, undefined);
    }
    var x = Curry._1(gen1, undefined);
    if (x !== undefined) {
      return x;
    } else {
      first.contents = false;
      return Curry._1(gen2, undefined);
    }
  };
}

function flatten(next_gen) {
  var state = {
    contents: /* Init */0
  };
  var next = function (param) {
    var gen = state.contents;
    if (typeof gen === "number") {
      if (gen !== 0) {
        return ;
      } else {
        return get_next_gen(undefined);
      }
    }
    var x = Curry._1(gen._0, undefined);
    if (x !== undefined) {
      return x;
    } else {
      return get_next_gen(undefined);
    }
  };
  var get_next_gen = function (param) {
    var gen = Curry._1(next_gen, undefined);
    if (gen !== undefined) {
      state.contents = /* Run */{
        _0: gen
      };
      return next(undefined);
    } else {
      state.contents = /* Stop */1;
      return ;
    }
  };
  return next;
}

function flat_map(f, next_elem) {
  var state = {
    contents: /* Init */0
  };
  var next = function (param) {
    var gen = state.contents;
    if (typeof gen === "number") {
      if (gen !== 0) {
        return ;
      } else {
        return get_next_gen(undefined);
      }
    }
    var x = Curry._1(gen._0, undefined);
    if (x !== undefined) {
      return x;
    } else {
      return get_next_gen(undefined);
    }
  };
  var get_next_gen = function (param) {
    var x = Curry._1(next_elem, undefined);
    if (x !== undefined) {
      try {
        state.contents = /* Run */{
          _0: Curry._1(f, Caml_option.valFromOption(x))
        };
      }
      catch (e){
        state.contents = /* Stop */1;
        throw e;
      }
      return next(undefined);
    }
    state.contents = /* Stop */1;
    
  };
  return next;
}

function mem(eqOpt, x, gen) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  while(true) {
    var y = Curry._1(gen, undefined);
    if (y === undefined) {
      return false;
    }
    if (Curry._2(eq, x, Caml_option.valFromOption(y))) {
      return true;
    }
    continue ;
  };
}

function take(n, gen) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            449,
            2
          ],
          Error: new Error()
        };
  }
  var count = {
    contents: 0
  };
  return function (param) {
    if (count.contents === n || count.contents === -1) {
      return ;
    }
    var x = Curry._1(gen, undefined);
    if (x !== undefined) {
      count.contents = count.contents + 1 | 0;
      return x;
    } else {
      count.contents = -1;
      return ;
    }
  };
}

function __drop(_n, gen) {
  while(true) {
    var n = _n;
    if (n === 0) {
      return ;
    }
    var match = Curry._1(gen, undefined);
    if (match === undefined) {
      return ;
    }
    _n = n - 1 | 0;
    continue ;
  };
}

function drop(n, gen) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            483,
            2
          ],
          Error: new Error()
        };
  }
  var dropped = {
    contents: false
  };
  return function (param) {
    if (dropped.contents) {
      return Curry._1(gen, undefined);
    } else {
      dropped.contents = true;
      __drop(n, gen);
      return Curry._1(gen, undefined);
    }
  };
}

function nth(n, gen) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            503,
            2
          ],
          Error: new Error()
        };
  }
  __drop(n, gen);
  var x = Curry._1(gen, undefined);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function take_nth(n, gen) {
  if (n < 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            521,
            2
          ],
          Error: new Error()
        };
  }
  var i = {
    contents: n
  };
  var next = function (_param) {
    while(true) {
      var res = Curry._1(gen, undefined);
      if (res === undefined) {
        return ;
      }
      if (i.contents === n) {
        i.contents = 1;
        return res;
      }
      i.contents = i.contents + 1 | 0;
      _param = undefined;
      continue ;
    };
  };
  return next;
}

function filter(p, gen) {
  var next = function (_param) {
    while(true) {
      var res = Curry._1(gen, undefined);
      if (res === undefined) {
        return ;
      }
      if (Curry._1(p, Caml_option.valFromOption(res))) {
        return res;
      }
      _param = undefined;
      continue ;
    };
  };
  return next;
}

function take_while(p, gen) {
  var stop = {
    contents: false
  };
  return function (param) {
    if (stop.contents) {
      return ;
    }
    var res = Curry._1(gen, undefined);
    if (res !== undefined && Curry._1(p, Caml_option.valFromOption(res))) {
      return res;
    } else {
      stop.contents = true;
      return ;
    }
  };
}

function fold_while(f, s, gen) {
  var state = {
    contents: s
  };
  var consume = function (gen) {
    while(true) {
      var x = Curry._1(gen, undefined);
      if (x === undefined) {
        return ;
      }
      var match = Curry._2(f, state.contents, Caml_option.valFromOption(x));
      state.contents = match[0];
      if (match[1] === "Stop") {
        return ;
      }
      continue ;
    };
  };
  consume(gen);
  return state.contents;
}

var DropWhileState = {};

function drop_while(p, gen) {
  var state = {
    contents: /* Drop */1
  };
  var next = function (_param) {
    while(true) {
      var match = state.contents;
      switch (match) {
        case /* Stop */0 :
            return ;
        case /* Drop */1 :
            var res = Curry._1(gen, undefined);
            if (res !== undefined) {
              if (Curry._1(p, Caml_option.valFromOption(res))) {
                _param = undefined;
                continue ;
              }
              state.contents = /* Yield */2;
              return res;
            }
            state.contents = /* Stop */0;
            return ;
        case /* Yield */2 :
            var res$1 = Curry._1(gen, undefined);
            if (res$1 !== undefined) {
              return res$1;
            } else {
              state.contents = /* Stop */0;
              return ;
            }
        
      }
    };
  };
  return next;
}

function filter_map(f, gen) {
  var next = function (_param) {
    while(true) {
      var x = Curry._1(gen, undefined);
      if (x === undefined) {
        return ;
      }
      var res = Curry._1(f, Caml_option.valFromOption(x));
      if (res !== undefined) {
        return res;
      }
      _param = undefined;
      continue ;
    };
  };
  return next;
}

function zip_index(gen) {
  var r = {
    contents: -1
  };
  return function (param) {
    var x = Curry._1(gen, undefined);
    if (x !== undefined) {
      r.contents = r.contents + 1 | 0;
      return [
              r.contents,
              Caml_option.valFromOption(x)
            ];
    }
    
  };
}

function unzip(gen) {
  var stop = {
    contents: false
  };
  var q1 = Queue.create(undefined);
  var q2 = Queue.create(undefined);
  var next_left = function (param) {
    if (!Queue.is_empty(q1)) {
      return Caml_option.some(Queue.pop(q1));
    }
    if (stop.contents) {
      return ;
    }
    var match = Curry._1(gen, undefined);
    if (match !== undefined) {
      Queue.push(match[1], q2);
      return Caml_option.some(match[0]);
    } else {
      stop.contents = true;
      return ;
    }
  };
  var next_right = function (param) {
    if (!Queue.is_empty(q2)) {
      return Caml_option.some(Queue.pop(q2));
    }
    if (stop.contents) {
      return ;
    }
    var match = Curry._1(gen, undefined);
    if (match !== undefined) {
      Queue.push(match[0], q1);
      return Caml_option.some(match[1]);
    } else {
      stop.contents = true;
      return ;
    }
  };
  return [
          next_left,
          next_right
        ];
}

function partition(p, gen) {
  var qtrue = Queue.create(undefined);
  var qfalse = Queue.create(undefined);
  var stop = {
    contents: false
  };
  var nexttrue = function (_param) {
    while(true) {
      if (!Queue.is_empty(qtrue)) {
        return Caml_option.some(Queue.pop(qtrue));
      }
      if (stop.contents) {
        return ;
      }
      var res = Curry._1(gen, undefined);
      if (res !== undefined) {
        var x = Caml_option.valFromOption(res);
        if (Curry._1(p, x)) {
          return res;
        }
        Queue.push(x, qfalse);
        _param = undefined;
        continue ;
      }
      stop.contents = true;
      return ;
    };
  };
  var nextfalse = function (_param) {
    while(true) {
      if (!Queue.is_empty(qfalse)) {
        return Caml_option.some(Queue.pop(qfalse));
      }
      if (stop.contents) {
        return ;
      }
      var res = Curry._1(gen, undefined);
      if (res !== undefined) {
        var x = Caml_option.valFromOption(res);
        if (!Curry._1(p, x)) {
          return res;
        }
        Queue.push(x, qtrue);
        _param = undefined;
        continue ;
      }
      stop.contents = true;
      return ;
    };
  };
  return [
          nexttrue,
          nextfalse
        ];
}

function for_all(p, gen) {
  while(true) {
    var x = Curry._1(gen, undefined);
    if (x === undefined) {
      return true;
    }
    if (!Curry._1(p, Caml_option.valFromOption(x))) {
      return false;
    }
    continue ;
  };
}

function exists(p, gen) {
  while(true) {
    var x = Curry._1(gen, undefined);
    if (x === undefined) {
      return false;
    }
    if (Curry._1(p, Caml_option.valFromOption(x))) {
      return true;
    }
    continue ;
  };
}

function min(ltOpt, gen) {
  var lt = ltOpt !== undefined ? ltOpt : Caml_obj.caml_lessthan;
  var x = Curry._1(gen, undefined);
  var first;
  if (x !== undefined) {
    first = Caml_option.valFromOption(x);
  } else {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "min",
          Error: new Error()
        };
  }
  return fold((function (min, x) {
                if (Curry._2(lt, x, min)) {
                  return x;
                } else {
                  return min;
                }
              }), first, gen);
}

function max(ltOpt, gen) {
  var lt = ltOpt !== undefined ? ltOpt : Caml_obj.caml_lessthan;
  var x = Curry._1(gen, undefined);
  var first;
  if (x !== undefined) {
    first = Caml_option.valFromOption(x);
  } else {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "max",
          Error: new Error()
        };
  }
  return fold((function (max, x) {
                if (Curry._2(lt, max, x)) {
                  return x;
                } else {
                  return max;
                }
              }), first, gen);
}

function eq(eqOpt, gen1, gen2) {
  var eq$1 = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var _param;
  while(true) {
    var match = Curry._1(gen1, undefined);
    var match$1 = Curry._1(gen2, undefined);
    if (match === undefined) {
      return match$1 === undefined;
    }
    if (match$1 === undefined) {
      return false;
    }
    if (!Curry._2(eq$1, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) {
      return false;
    }
    _param = undefined;
    continue ;
  };
}

function lexico(cmpOpt, gen1, gen2) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var _param;
  while(true) {
    var match = Curry._1(gen1, undefined);
    var match$1 = Curry._1(gen2, undefined);
    if (match === undefined) {
      if (match$1 !== undefined) {
        return -1;
      } else {
        return 0;
      }
    }
    if (match$1 === undefined) {
      return 1;
    }
    var c = Curry._2(cmp, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
    if (c !== 0) {
      return c;
    }
    _param = undefined;
    continue ;
  };
}

var compare = lexico;

function find(p, e) {
  while(true) {
    var x = Curry._1(e, undefined);
    if (x === undefined) {
      return ;
    }
    var x$1 = Caml_option.valFromOption(x);
    if (Curry._1(p, x$1)) {
      return Caml_option.some(x$1);
    }
    continue ;
  };
}

function sum(e) {
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var x = Curry._1(e, undefined);
    if (x === undefined) {
      return acc;
    }
    _acc = x + acc | 0;
    continue ;
  };
}

function map2(f, e1, e2, param) {
  var match = Curry._1(e1, undefined);
  var match$1 = Curry._1(e2, undefined);
  if (match !== undefined && match$1 !== undefined) {
    return Caml_option.some(Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1)));
  }
  
}

function iter2(f, e1, e2) {
  while(true) {
    var match = Curry._1(e1, undefined);
    var match$1 = Curry._1(e2, undefined);
    if (match === undefined) {
      return ;
    }
    if (match$1 === undefined) {
      return ;
    }
    Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
    continue ;
  };
}

function fold2(f, _acc, e1, e2) {
  while(true) {
    var acc = _acc;
    var match = Curry._1(e1, undefined);
    var match$1 = Curry._1(e2, undefined);
    if (match === undefined) {
      return acc;
    }
    if (match$1 === undefined) {
      return acc;
    }
    _acc = Curry._3(f, acc, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
    continue ;
  };
}

function for_all2(p, e1, e2) {
  while(true) {
    var match = Curry._1(e1, undefined);
    var match$1 = Curry._1(e2, undefined);
    if (match === undefined) {
      return true;
    }
    if (match$1 === undefined) {
      return true;
    }
    if (!Curry._2(p, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) {
      return false;
    }
    continue ;
  };
}

function exists2(p, e1, e2) {
  while(true) {
    var match = Curry._1(e1, undefined);
    var match$1 = Curry._1(e2, undefined);
    if (match === undefined) {
      return false;
    }
    if (match$1 === undefined) {
      return false;
    }
    if (Curry._2(p, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) {
      return true;
    }
    continue ;
  };
}

function zip_with(f, a, b) {
  var stop = {
    contents: false
  };
  return function (param) {
    if (stop.contents) {
      return ;
    }
    var match = Curry._1(a, undefined);
    var match$1 = Curry._1(b, undefined);
    if (match !== undefined && match$1 !== undefined) {
      return Caml_option.some(Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1)));
    } else {
      stop.contents = true;
      return ;
    }
  };
}

function zip(a, b) {
  return zip_with((function (x, y) {
                return [
                        x,
                        y
                      ];
              }), a, b);
}

var MergeState = {};

function merge(next_gen) {
  var state = {
    gens: Queue.create(undefined),
    state: /* NewGen */0
  };
  var next = function (_param) {
    while(true) {
      var match = state.state;
      switch (match) {
        case /* NewGen */0 :
            var gen = Curry._1(next_gen, undefined);
            if (gen !== undefined) {
              Queue.push(gen, state.gens);
              state.state = /* YieldAndNew */1;
              _param = undefined;
              continue ;
            }
            state.state = /* Yield */2;
            _param = undefined;
            continue ;
        case /* YieldAndNew */1 :
            if (Queue.is_empty(state.gens)) {
              state.state = /* NewGen */0;
              _param = undefined;
              continue ;
            }
            var gen$1 = Queue.pop(state.gens);
            var res = Curry._1(gen$1, undefined);
            if (res !== undefined) {
              Queue.push(gen$1, state.gens);
              state.state = /* NewGen */0;
              return res;
            }
            state.state = /* NewGen */0;
            _param = undefined;
            continue ;
        case /* Yield */2 :
            if (Queue.is_empty(state.gens)) {
              state.state = /* Stop */3;
              return ;
            }
            var gen$2 = Queue.pop(state.gens);
            var res$1 = Curry._1(gen$2, undefined);
            if (res$1 !== undefined) {
              Queue.push(gen$2, state.gens);
              return res$1;
            }
            _param = undefined;
            continue ;
        case /* Stop */3 :
            return ;
        
      }
    };
  };
  return next;
}

function intersection(cmpOpt, gen1, gen2) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var x1 = {
    contents: Curry._1(gen1, undefined)
  };
  var x2 = {
    contents: Curry._1(gen2, undefined)
  };
  var next = function (_param) {
    while(true) {
      var match = x1.contents;
      var match$1 = x2.contents;
      if (match === undefined) {
        return ;
      }
      if (match$1 === undefined) {
        return ;
      }
      var y1 = Caml_option.valFromOption(match);
      var c = Curry._2(cmp, y1, Caml_option.valFromOption(match$1));
      if (c === 0) {
        x1.contents = Curry._1(gen1, undefined);
        x2.contents = Curry._1(gen2, undefined);
        return Caml_option.some(y1);
      }
      if (c < 0) {
        x1.contents = Curry._1(gen1, undefined);
        _param = undefined;
        continue ;
      }
      x2.contents = Curry._1(gen2, undefined);
      _param = undefined;
      continue ;
    };
  };
  return next;
}

function sorted_merge(cmpOpt, gen1, gen2) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var x1 = {
    contents: Curry._1(gen1, undefined)
  };
  var x2 = {
    contents: Curry._1(gen2, undefined)
  };
  return function (param) {
    var match = x1.contents;
    var match$1 = x2.contents;
    if (match !== undefined) {
      if (match$1 !== undefined && Curry._2(cmp, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1)) > 0) {
        x2.contents = Curry._1(gen2, undefined);
        return match$1;
      } else {
        x1.contents = Curry._1(gen1, undefined);
        return match;
      }
    } else if (match$1 !== undefined) {
      x2.contents = Curry._1(gen2, undefined);
      return match$1;
    } else {
      return ;
    }
  };
}

function empty$1(cmp) {
  return {
          tree: /* Empty */0,
          cmp: cmp
        };
}

function is_empty$1(h) {
  var match = h.tree;
  if (match) {
    return false;
  } else {
    return true;
  }
}

function union(cmp, t1, t2) {
  if (!t1) {
    return t2;
  }
  if (!t2) {
    return t1;
  }
  var x2 = t2._0;
  var x1 = t1._0;
  if (Curry._2(cmp, x1, x2) <= 0) {
    return /* Node */{
            _0: x1,
            _1: union(cmp, t2, t1._2),
            _2: t1._1
          };
  } else {
    return /* Node */{
            _0: x2,
            _1: union(cmp, t1, t2._2),
            _2: t2._1
          };
  }
}

function insert(h, x) {
  h.tree = union(h.cmp, /* Node */{
        _0: x,
        _1: /* Empty */0,
        _2: /* Empty */0
      }, h.tree);
  
}

function pop(h) {
  var match = h.tree;
  if (match) {
    h.tree = union(h.cmp, match._1, match._2);
    return match._0;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var Heap = {
  empty: empty$1,
  is_empty: is_empty$1,
  union: union,
  insert: insert,
  pop: pop
};

function sorted_merge_n(cmpOpt, l) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var cmp$1 = function (param, param$1) {
    return Curry._2(cmp, param[0], param$1[0]);
  };
  var heap = {
    tree: /* Empty */0,
    cmp: cmp$1
  };
  List.iter((function (gen$prime) {
          var x = Curry._1(gen$prime, undefined);
          if (x !== undefined) {
            return insert(heap, [
                        Caml_option.valFromOption(x),
                        gen$prime
                      ]);
          }
          
        }), l);
  return function (param) {
    if (is_empty$1(heap)) {
      return ;
    }
    var match = pop(heap);
    var gen = match[1];
    var x = match[0];
    var y = Curry._1(gen, undefined);
    if (y !== undefined) {
      insert(heap, [
            Caml_option.valFromOption(y),
            gen
          ]);
      return Caml_option.some(x);
    } else {
      return Caml_option.some(x);
    }
  };
}

function round_robin(nOpt, gen) {
  var n = nOpt !== undefined ? nOpt : 2;
  var qs = $$Array.init(n, (function (param) {
          return Queue.create(undefined);
        }));
  var cur = {
    contents: 0
  };
  return $$Array.to_list($$Array.mapi((function (i, param, param$1) {
                    var q = Caml_array.get(qs, i);
                    if (Queue.is_empty(q)) {
                      while(true) {
                        var x = Curry._1(gen, undefined);
                        if (x === undefined) {
                          return ;
                        }
                        var x$1 = Caml_option.valFromOption(x);
                        var j = cur.contents;
                        cur.contents = Caml_int32.mod_(j + 1 | 0, n);
                        var q$1 = Caml_array.get(qs, j);
                        if (j === i) {
                          if (!Queue.is_empty(q$1)) {
                            throw {
                                  RE_EXN_ID: "Assert_failure",
                                  _1: [
                                    "gen.re",
                                    1267,
                                    8
                                  ],
                                  Error: new Error()
                                };
                          }
                          return Caml_option.some(x$1);
                        }
                        Queue.push(x$1, q$1);
                        continue ;
                      };
                    } else {
                      return Caml_option.some(Queue.pop(q));
                    }
                  }), qs));
}

function tee(nOpt, gen) {
  var n = nOpt !== undefined ? nOpt : 2;
  var qs = $$Array.init(n, (function (param) {
          return Queue.create(undefined);
        }));
  var finished = {
    contents: false
  };
  return $$Array.to_list($$Array.mapi((function (i, param, param$1) {
                    if (Queue.is_empty(Caml_array.get(qs, i))) {
                      if (finished.contents) {
                        return ;
                      } else {
                        var res = Curry._1(gen, undefined);
                        if (res !== undefined) {
                          for(var j = 0; j < n; ++j){
                            if (j !== i) {
                              Queue.push(res, Caml_array.get(qs, j));
                            }
                            
                          }
                          return res;
                        }
                        finished.contents = true;
                        return ;
                      }
                    } else {
                      return Queue.pop(Caml_array.get(qs, i));
                    }
                  }), qs));
}

var InterleaveState = {};

function interleave(gen_a, gen_b) {
  var state = {
    contents: {
      TAG: /* Both */1,
      _0: gen_a,
      _1: gen_b,
      _2: {
        contents: true
      }
    }
  };
  var next = function (_param) {
    while(true) {
      var g = state.contents;
      if (typeof g === "number") {
        return ;
      }
      if (g.TAG === /* Only */0) {
        var res = Curry._1(g._0, undefined);
        if (res !== undefined) {
          return res;
        } else {
          state.contents = /* Stop */0;
          return ;
        }
      }
      var r = g._2;
      var g2 = g._1;
      var g1 = g._0;
      var res$1 = r.contents ? Curry._1(g1, undefined) : Curry._1(g2, undefined);
      if (res$1 !== undefined) {
        r.contents = !r.contents;
        return res$1;
      }
      state.contents = r.contents ? ({
            TAG: /* Only */0,
            _0: g2
          }) : ({
            TAG: /* Only */0,
            _0: g1
          });
      _param = undefined;
      continue ;
    };
  };
  return next;
}

var IntersperseState = {};

function intersperse(x, gen) {
  var state = {
    contents: /* Start */0
  };
  var next = function (_param) {
    while(true) {
      var res = state.contents;
      if (typeof res === "number") {
        if (res !== /* Start */0) {
          return ;
        }
        var res$1 = Curry._1(gen, undefined);
        if (res$1 !== undefined) {
          state.contents = {
            TAG: /* YieldElem */0,
            _0: res$1
          };
          _param = undefined;
          continue ;
        }
        state.contents = /* Stop */1;
        return ;
      } else {
        if (res.TAG === /* YieldElem */0) {
          var res$prime = Curry._1(gen, undefined);
          if (res$prime !== undefined) {
            state.contents = {
              TAG: /* YieldSep */1,
              _0: res$prime
            };
          } else {
            state.contents = /* Stop */1;
          }
          return res._0;
        }
        state.contents = {
          TAG: /* YieldElem */0,
          _0: res._0
        };
        return Caml_option.some(x);
      }
    };
  };
  return next;
}

function product(gena, genb) {
  var all_a = {
    contents: /* [] */0
  };
  var all_b = {
    contents: /* [] */0
  };
  var cur = {
    contents: "GetLeft"
  };
  var next = function (_param) {
    while(true) {
      var match = cur.contents;
      if (typeof match === "string") {
        if (match === "GetLeft") {
          var a = Curry._1(gena, undefined);
          if (a !== undefined) {
            var a$1 = Caml_option.valFromOption(a);
            all_a.contents = {
              hd: a$1,
              tl: all_a.contents
            };
            cur.contents = {
              NAME: "ProdLeft",
              VAL: [
                a$1,
                all_b.contents
              ]
            };
          } else {
            cur.contents = "GetRightOrStop";
          }
          _param = undefined;
          continue ;
        }
        if (match === "Stop") {
          return ;
        }
        var b = Curry._1(genb, undefined);
        if (b !== undefined) {
          var b$1 = Caml_option.valFromOption(b);
          all_b.contents = {
            hd: b$1,
            tl: all_b.contents
          };
          cur.contents = {
            NAME: "ProdRight",
            VAL: [
              b$1,
              all_a.contents
            ]
          };
        } else if (cur.contents === "GetRightOrStop") {
          cur.contents = "Stop";
        } else {
          cur.contents = "GetLeft";
        }
        _param = undefined;
        continue ;
      }
      if (match.NAME === "ProdLeft") {
        var match$1 = match.VAL;
        var match$2 = match$1[1];
        var x = match$1[0];
        if (match$2) {
          cur.contents = {
            NAME: "ProdLeft",
            VAL: [
              x,
              match$2.tl
            ]
          };
          return [
                  x,
                  match$2.hd
                ];
        }
        cur.contents = "GetRight";
        _param = undefined;
        continue ;
      }
      var match$3 = match.VAL;
      var match$4 = match$3[1];
      var y = match$3[0];
      if (match$4) {
        cur.contents = {
          NAME: "ProdRight",
          VAL: [
            y,
            match$4.tl
          ]
        };
        return [
                match$4.hd,
                y
              ];
      }
      cur.contents = "GetLeft";
      _param = undefined;
      continue ;
    };
  };
  return next;
}

function group(eqOpt, gen) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var x = Curry._1(gen, undefined);
  if (x === undefined) {
    return function (param) {
      
    };
  }
  var cur = {
    contents: {
      hd: Caml_option.valFromOption(x),
      tl: /* [] */0
    }
  };
  var next = function (_param) {
    while(true) {
      var next_x = cur.contents === /* [] */0 ? undefined : Curry._1(gen, undefined);
      var match = cur.contents;
      if (next_x === undefined) {
        if (match) {
          cur.contents = /* [] */0;
          return match;
        } else {
          return ;
        }
      }
      var x = Caml_option.valFromOption(next_x);
      if (match && Curry._2(eq, x, match.hd)) {
        cur.contents = {
          hd: x,
          tl: cur.contents
        };
        _param = undefined;
        continue ;
      }
      cur.contents = {
        hd: x,
        tl: /* [] */0
      };
      return match;
    };
  };
  return next;
}

function uniq(eqOpt, gen) {
  var eq = eqOpt !== undefined ? eqOpt : Caml_obj.caml_equal;
  var state = {
    contents: /* Init */0
  };
  var next = function (_param) {
    while(true) {
      var x = state.contents;
      if (typeof x === "number") {
        if (x !== 0) {
          return ;
        }
        var res = Curry._1(gen, undefined);
        if (res !== undefined) {
          state.contents = /* Run */{
            _0: Caml_option.valFromOption(res)
          };
          return res;
        } else {
          state.contents = /* Stop */1;
          return ;
        }
      }
      var res$1 = Curry._1(gen, undefined);
      if (res$1 !== undefined) {
        var y = Caml_option.valFromOption(res$1);
        if (Curry._2(eq, x._0, y)) {
          _param = undefined;
          continue ;
        }
        state.contents = /* Run */{
          _0: y
        };
        return res$1;
      }
      state.contents = /* Stop */1;
      return ;
    };
  };
  return next;
}

function sort(cmpOpt, gen) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var h = {
    tree: /* Empty */0,
    cmp: cmp
  };
  iter((function (param) {
          return insert(h, param);
        }), gen);
  return function (param) {
    if (is_empty$1(h)) {
      return ;
    } else {
      return Caml_option.some(pop(h));
    }
  };
}

function sort_uniq(cmpOpt, gen) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  return uniq((function (x, y) {
                return Curry._2(cmp, x, y) === 0;
              }), sort(cmp, gen));
}

function chunks(n, e) {
  return function (param) {
    var x = Curry._1(e, undefined);
    if (x === undefined) {
      return ;
    }
    var a = Caml_array.caml_make_vect(n, Caml_option.valFromOption(x));
    var _i = 1;
    while(true) {
      var i = _i;
      if (i === n) {
        return a;
      }
      var x$1 = Curry._1(e, undefined);
      if (x$1 === undefined) {
        return $$Array.sub(a, 0, i);
      }
      Caml_array.set(a, i, Caml_option.valFromOption(x$1));
      _i = i + 1 | 0;
      continue ;
    };
  };
}

var PermState = {};

function permutations(g) {
  var make_machine = function (n, l) {
    if (l) {
      var sub = make_machine(n - 1 | 0, l.tl);
      var l$1 = next(sub, undefined);
      var st = l$1 !== undefined ? /* Insert */({
            _0: {
              x: l.hd,
              l: l$1,
              n: 0,
              len: n,
              sub: sub
            }
          }) : /* Done */0;
      return {
              st: st
            };
    }
    if (n !== 0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "gen.re",
              1676,
              6
            ],
            Error: new Error()
          };
    }
    return {
            st: /* Base */1
          };
  };
  var next = function (m, _param) {
    while(true) {
      var state = m.st;
      if (typeof state === "number") {
        if (state !== 0) {
          m.st = /* Done */0;
          return /* [] */0;
        } else {
          return ;
        }
      }
      var state$1 = state._0;
      var l = state$1.l;
      var n = state$1.n;
      if (n === state$1.len) {
        var l$1 = next(state$1.sub, undefined);
        if (l$1 !== undefined) {
          state$1.l = l$1;
          state$1.n = 0;
          _param = undefined;
          continue ;
        }
        m.st = /* Done */0;
        return ;
      }
      state$1.n = state$1.n + 1 | 0;
      return insert(state$1.x, n, l);
    };
  };
  var insert = function (x, n, l) {
    if (n === 0) {
      return {
              hd: x,
              tl: l
            };
    }
    if (l) {
      return {
              hd: l.hd,
              tl: insert(x, n - 1 | 0, l.tl)
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            1714,
            17
          ],
          Error: new Error()
        };
  };
  var l = fold((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, g);
  var partial_arg = make_machine(List.length(l), l);
  return function (param) {
    return next(partial_arg, param);
  };
}

var HeapPermState = {};

function permutations_heap(g) {
  var l = fold((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, g);
  var a = $$Array.of_list(l);
  var n = a.length;
  if (n === 0) {
    return empty;
  }
  var partial_arg = {
    elts: a,
    n: n,
    is: {
      hd: 0,
      tl: /* [] */0
    }
  };
  return function (param) {
    var _param = param;
    while(true) {
      var n = partial_arg.n;
      if (n !== 0) {
        var match = partial_arg.is;
        if (!match) {
          return ;
        }
        if (match.hd === n) {
          partial_arg.is = match.tl;
          partial_arg.n = n + 1 | 0;
          var match$1 = partial_arg.is;
          if (!match$1) {
            return ;
          }
          var i = match$1.hd;
          var j = partial_arg.n % 2 === 1 ? 0 : i;
          var tmp = Caml_array.get(partial_arg.elts, j);
          Caml_array.set(partial_arg.elts, j, Caml_array.get(partial_arg.elts, n));
          Caml_array.set(partial_arg.elts, n, tmp);
          partial_arg.is = {
            hd: i + 1 | 0,
            tl: match$1.tl
          };
          _param = undefined;
          continue ;
        }
        partial_arg.n = n - 1 | 0;
        partial_arg.is = {
          hd: 0,
          tl: partial_arg.is
        };
        _param = undefined;
        continue ;
      }
      var match$2 = partial_arg.is;
      if (match$2) {
        if (match$2.hd === 0) {
          var match$3 = match$2.tl;
          if (match$3) {
            partial_arg.is = {
              hd: match$3.hd + 1 | 0,
              tl: match$3.tl
            };
            partial_arg.n = 1;
            return $$Array.copy(a);
          }
          
        }
        if (match$2.tl) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "gen.re",
                  1781,
                  24
                ],
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "gen.re",
                1775,
                15
              ],
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "gen.re",
              1775,
              15
            ],
            Error: new Error()
          };
    };
  };
}

var CombState = {};

function combinations(n, g) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            1839,
            2
          ],
          Error: new Error()
        };
  }
  var make_state = function (n, l) {
    if (n === 0) {
      return {
              st: /* Base */1
            };
    }
    if (!l) {
      return {
              st: /* Done */0
            };
    }
    var tail = l.tl;
    var m1 = make_state(n - 1 | 0, tail);
    var m2 = make_state(n, tail);
    return {
            st: {
              TAG: /* Add */0,
              _0: l.hd,
              _1: m1,
              _2: m2
            }
          };
  };
  var next = function (m, _param) {
    while(true) {
      var m$1 = m.st;
      if (typeof m$1 === "number") {
        if (m$1 === /* Done */0) {
          return ;
        }
        m.st = /* Done */0;
        return /* [] */0;
      } else {
        if (m$1.TAG === /* Add */0) {
          var l = next(m$1._1, undefined);
          if (l !== undefined) {
            return {
                    hd: m$1._0,
                    tl: l
                  };
          }
          m.st = {
            TAG: /* Follow */1,
            _0: m$1._2
          };
          _param = undefined;
          continue ;
        }
        var m$2 = m$1._0;
        var res = next(m$2, undefined);
        if (res !== undefined) {
          return res;
        } else {
          m$2.st = /* Done */0;
          return ;
        }
      }
    };
  };
  var l = fold((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, g);
  var partial_arg = make_state(n, l);
  return function (param) {
    return next(partial_arg, param);
  };
}

var PowerSetState = {};

function power_set(g) {
  var make_state = function (l) {
    if (!l) {
      return {
              st: /* Base */1
            };
    }
    var m = make_state(l.tl);
    return {
            st: {
              TAG: /* Add */0,
              _0: l.hd,
              _1: m
            }
          };
  };
  var next = function (m, param) {
    var match = m.st;
    if (typeof match === "number") {
      if (match === /* Done */0) {
        return ;
      }
      m.st = /* Done */0;
      return /* [] */0;
    } else {
      if (match.TAG === /* Add */0) {
        var m$prime = match._1;
        var res = next(m$prime, undefined);
        if (res !== undefined) {
          m.st = {
            TAG: /* AddTo */1,
            _0: res,
            _1: match._0,
            _2: m$prime
          };
          return res;
        } else {
          m.st = /* Done */0;
          return ;
        }
      }
      var x = match._1;
      m.st = {
        TAG: /* Add */0,
        _0: x,
        _1: match._2
      };
      return {
              hd: x,
              tl: match._0
            };
    }
  };
  var l = fold((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, g);
  var partial_arg = make_state(l);
  return function (param) {
    return next(partial_arg, param);
  };
}

function of_list(l) {
  var l$1 = {
    contents: l
  };
  return function (param) {
    var match = l$1.contents;
    if (match) {
      l$1.contents = match.tl;
      return Caml_option.some(match.hd);
    }
    
  };
}

function to_rev_list(gen) {
  return fold((function (acc, x) {
                return {
                        hd: x,
                        tl: acc
                      };
              }), /* [] */0, gen);
}

function to_list(gen) {
  return List.rev(to_rev_list(gen));
}

function to_array(gen) {
  var l = to_rev_list(gen);
  if (!l) {
    return [];
  }
  var a = $$Array.of_list(l);
  var n = a.length;
  for(var i = 0 ,i_finish = (n - 1 | 0) / 2 | 0; i <= i_finish; ++i){
    var tmp = Caml_array.get(a, i);
    Caml_array.set(a, i, Caml_array.get(a, (n - i | 0) - 1 | 0));
    Caml_array.set(a, (n - i | 0) - 1 | 0, tmp);
  }
  return a;
}

function of_array(startOpt, len, a) {
  var start = startOpt !== undefined ? startOpt : 0;
  var len$1;
  if (len !== undefined) {
    if ((len + start | 0) >= a.length) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "gen.re",
              1978,
              6
            ],
            Error: new Error()
          };
    }
    len$1 = len;
  } else {
    len$1 = a.length - start | 0;
  }
  var i = {
    contents: start
  };
  return function (param) {
    if (i.contents >= (start + len$1 | 0)) {
      return ;
    }
    var x = Caml_array.get(a, i.contents);
    i.contents = i.contents + 1 | 0;
    return Caml_option.some(x);
  };
}

function of_string(startOpt, len, s) {
  var start = startOpt !== undefined ? startOpt : 0;
  var len$1;
  if (len !== undefined) {
    if ((len + start | 0) >= s.length) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "gen.re",
              2002,
              6
            ],
            Error: new Error()
          };
    }
    len$1 = len;
  } else {
    len$1 = s.length - start | 0;
  }
  var i = {
    contents: start
  };
  return function (param) {
    if (i.contents >= (start + len$1 | 0)) {
      return ;
    }
    var x = Caml_string.get(s, i.contents);
    i.contents = i.contents + 1 | 0;
    return x;
  };
}

function to_buffer(buf, g) {
  return iter((function (param) {
                return $$Buffer.add_char(buf, param);
              }), g);
}

function to_string(s) {
  var buf = $$Buffer.create(16);
  iter((function (param) {
          return $$Buffer.add_char(buf, param);
        }), s);
  return $$Buffer.contents(buf);
}

function rand_int(i) {
  return function (param) {
    return Caml_option.some(Random.$$int(i));
  };
}

function int_range(stepOpt, i, j) {
  var step = stepOpt !== undefined ? stepOpt : 1;
  if (step === 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Gen.int_range",
          Error: new Error()
        };
  }
  var $great = step > 0 ? Caml_obj.caml_greaterthan : Caml_obj.caml_lessthan;
  var r = {
    contents: i
  };
  return function (param) {
    var x = r.contents;
    if (Curry._2($great, x, j)) {
      return ;
    } else {
      r.contents = r.contents + step | 0;
      return x;
    }
  };
}

function lines(g) {
  var buf = $$Buffer.create(32);
  var stop = {
    contents: false
  };
  var next = function (_param) {
    while(true) {
      if (stop.contents) {
        return ;
      }
      var c = Curry._1(g, undefined);
      if (c !== undefined) {
        if (c !== 10) {
          $$Buffer.add_char(buf, c);
          _param = undefined;
          continue ;
        }
        var s = $$Buffer.contents(buf);
        $$Buffer.clear(buf);
        return s;
      }
      stop.contents = true;
      if ($$Buffer.length(buf) === 0) {
        return ;
      } else {
        return $$Buffer.contents(buf);
      }
    };
  };
  return next;
}

function unlines(g) {
  var st = {
    contents: "Next"
  };
  return function (param) {
    var match = st.contents;
    if (typeof match === "string") {
      if (match === "Stop") {
        return ;
      }
      var s = Curry._1(g, undefined);
      if (s !== undefined) {
        if (s === "") {
          return /* "\n" */10;
        }
        st.contents = {
          NAME: "Consume",
          VAL: [
            s,
            1
          ]
        };
        return Caml_string.get(s, 0);
      }
      st.contents = "Stop";
      return ;
    }
    var match$1 = match.VAL;
    var i = match$1[1];
    var s$1 = match$1[0];
    if (i === s$1.length) {
      st.contents = "Next";
      return /* "\n" */10;
    } else {
      st.contents = {
        NAME: "Consume",
        VAL: [
          s$1,
          i + 1 | 0
        ]
      };
      return Caml_string.get(s$1, i);
    }
  };
}

function pp(startOpt, stopOpt, sepOpt, horizontalOpt, pp_elem, formatter, gen) {
  var start = startOpt !== undefined ? startOpt : "";
  var stop = stopOpt !== undefined ? stopOpt : "";
  var sep = sepOpt !== undefined ? sepOpt : ",";
  var horizontal = horizontalOpt !== undefined ? horizontalOpt : false;
  if (horizontal) {
    Format.pp_open_hbox(formatter, undefined);
  } else {
    Format.pp_open_hvbox(formatter, 0);
  }
  Format.pp_print_string(formatter, start);
  var next = function (_is_first) {
    while(true) {
      var is_first = _is_first;
      var x = Curry._1(gen, undefined);
      if (x === undefined) {
        return ;
      }
      var x$1 = Caml_option.valFromOption(x);
      if (is_first) {
        Curry._2(pp_elem, formatter, x$1);
      } else {
        Format.pp_print_string(formatter, sep);
        Format.pp_print_space(formatter, undefined);
        Curry._2(pp_elem, formatter, x$1);
      }
      _is_first = false;
      continue ;
    };
  };
  next(true);
  Format.pp_print_string(formatter, stop);
  return Format.pp_close_box(formatter, undefined);
}

var partial_arg = 1;

function $neg$neg(param, param$1) {
  return int_range(partial_arg, param, param$1);
}

function $great$great$eq(x, f) {
  return flat_map(f, x);
}

function $great$great$pipe(x, f) {
  return map(f, x);
}

function $great$pipe$eq(x, f) {
  return map(f, x);
}

var Infix = {
  $neg$neg: $neg$neg,
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe,
  $great$pipe$eq: $great$pipe$eq
};

function lift(f, e) {
  return Curry._1(f, Curry._1(e, undefined));
}

function lift2(f, e1, e2) {
  return Curry._2(f, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function empty$2(param) {
  return empty;
}

function singleton$1(x, param) {
  return singleton(x);
}

function iterate$1(x, f, param) {
  return iterate(x, f);
}

function repeat$1(x, param) {
  return function (param) {
    return Caml_option.some(x);
  };
}

function unfold$1(f, acc, param) {
  return unfold(f, acc);
}

function init$1(limit, f, param) {
  return init(limit, f);
}

function cycle($$enum) {
  if (is_empty(Curry._1($$enum, undefined))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "gen.re",
            2185,
            4
          ],
          Error: new Error()
        };
  }
  return function (param) {
    var gen = {
      contents: Curry._1($$enum, undefined)
    };
    var next = function (_param) {
      while(true) {
        var res = Curry._1(gen.contents, undefined);
        if (res !== undefined) {
          return res;
        }
        gen.contents = Curry._1($$enum, undefined);
        _param = undefined;
        continue ;
      };
    };
    return next;
  };
}

function is_empty$2(e) {
  return is_empty(Curry._1(e, undefined));
}

function fold$1(f, acc, e) {
  return fold(f, acc, Curry._1(e, undefined));
}

function reduce$1(f, e) {
  return reduce(f, Curry._1(e, undefined));
}

function scan$1(f, acc, e, param) {
  return scan(f, acc, Curry._1(e, undefined));
}

function unfold_scan$1(f, acc, e, param) {
  return unfold_scan(f, acc, Curry._1(e, undefined));
}

function iter$1(f, e) {
  return iter(f, Curry._1(e, undefined));
}

function iteri$1(f, e) {
  return iteri(f, Curry._1(e, undefined));
}

function length$1(e) {
  return length(Curry._1(e, undefined));
}

function map$1(f, e, param) {
  return map(f, Curry._1(e, undefined));
}

function mapi$1(f, e, param) {
  return mapi(f)(Curry._1(e, undefined));
}

function fold_map$1(f, s, e, param) {
  return fold_map(f, s, Curry._1(e, undefined));
}

function append$1(e1, e2, param) {
  return append(Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function flatten$1(e, param) {
  return flatten(Curry._1(e, undefined));
}

function flat_map$1(f, e, param) {
  return flat_map(f, Curry._1(e, undefined));
}

function mem$1(eq, x, e) {
  return mem(eq, x, Curry._1(e, undefined));
}

function take$1(n, e, param) {
  return take(n, Curry._1(e, undefined));
}

function drop$1(n, e, param) {
  return drop(n, Curry._1(e, undefined));
}

function nth$1(n, e) {
  return nth(n, Curry._1(e, undefined));
}

function take_nth$1(n, e, param) {
  return take_nth(n, Curry._1(e, undefined));
}

function filter$1(p, e, param) {
  return filter(p, Curry._1(e, undefined));
}

function take_while$1(p, e, param) {
  return take_while(p, Curry._1(e, undefined));
}

function fold_while$1(f, s, e) {
  return fold_while(f, s, Curry._1(e, undefined));
}

function drop_while$1(p, e, param) {
  return drop_while(p, Curry._1(e, undefined));
}

function filter_map$1(f, e, param) {
  return filter_map(f, Curry._1(e, undefined));
}

function zip_with$1(f, e1, e2, param) {
  return zip_with(f, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function zip$1(e1, e2, param) {
  return zip(Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function zip_index$1(e, param) {
  return zip_index(Curry._1(e, undefined));
}

function unzip$1(e) {
  return [
          (function (param) {
              return map((function (prim) {
                            return prim[0];
                          }), Curry._1(e, undefined));
            }),
          (function (param) {
              return map((function (prim) {
                            return prim[1];
                          }), Curry._1(e, undefined));
            })
        ];
}

function partition$1(p, e) {
  return [
          (function (param) {
              return filter(p, Curry._1(e, undefined));
            }),
          (function (param) {
              return filter((function (x) {
                            return !Curry._1(p, x);
                          }), Curry._1(e, undefined));
            })
        ];
}

function for_all$1(p, e) {
  return for_all(p, Curry._1(e, undefined));
}

function exists$1(p, e) {
  return exists(p, Curry._1(e, undefined));
}

function for_all2$1(p, e1, e2) {
  return for_all2(p, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function exists2$1(p, e1, e2) {
  return exists2(p, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function map2$1(f, e1, e2, param) {
  var partial_arg = Curry._1(e2, undefined);
  var partial_arg$1 = Curry._1(e1, undefined);
  return function (param) {
    return map2(f, partial_arg$1, partial_arg, param);
  };
}

function iter2$1(f, e1, e2) {
  return iter2(f, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function fold2$1(f, acc, e1, e2) {
  return fold2(f, acc, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function min$1(lt, e) {
  return min(lt, Curry._1(e, undefined));
}

function max$1(lt, e) {
  return max(lt, Curry._1(e, undefined));
}

function eq$1(eq$2, e1, e2) {
  return eq(eq$2, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function lexico$1(cmp, e1, e2) {
  return lexico(cmp, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function compare$1(cmp, e1, e2) {
  return lexico(cmp, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function sum$1(e) {
  return sum(Curry._1(e, undefined));
}

function find$1(f, e) {
  return find(f, Curry._1(e, undefined));
}

function merge$1(e, param) {
  return merge(Curry._1(e, undefined));
}

function intersection$1(cmp, e1, e2, param) {
  return intersection(cmp, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function sorted_merge$1(cmp, e1, e2, param) {
  return sorted_merge(cmp, Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function sorted_merge_n$1(cmp, l, param) {
  return sorted_merge_n(cmp, List.map((function (g) {
                    return Curry._1(g, undefined);
                  }), l));
}

function tee$1(n, e) {
  return tee(n, Curry._1(e, undefined));
}

function round_robin$1(n, e) {
  return round_robin(n, Curry._1(e, undefined));
}

function interleave$1(e1, e2, param) {
  return interleave(Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function intersperse$1(x, e, param) {
  return intersperse(x, Curry._1(e, undefined));
}

function product$1(e1, e2, param) {
  return product(Curry._1(e1, undefined), Curry._1(e2, undefined));
}

function group$1(eq, e, param) {
  return group(eq, Curry._1(e, undefined));
}

function uniq$1(eq, e, param) {
  return uniq(eq, Curry._1(e, undefined));
}

function sort$1(cmpOpt, $$enum, param) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  return sort(cmp, Curry._1($$enum, undefined));
}

function sort_uniq$1(cmpOpt, e) {
  var cmp = cmpOpt !== undefined ? cmpOpt : Caml_obj.caml_compare;
  var partial_arg = cmp;
  var e$prime = function (param) {
    return sort$1(partial_arg, e, param);
  };
  var partial_arg$1 = (function (x, y) {
      return Curry._2(cmp, x, y) === 0;
    });
  return function (param) {
    return uniq(partial_arg$1, Curry._1(e$prime, undefined));
  };
}

function chunks$1(n, e, param) {
  return chunks(n, Curry._1(e, undefined));
}

function permutations$1(g, param) {
  return permutations(Curry._1(g, undefined));
}

function permutations_heap$1(g, param) {
  return permutations_heap(Curry._1(g, undefined));
}

function combinations$1(n, g, param) {
  return combinations(n, Curry._1(g, undefined));
}

function power_set$1(g, param) {
  return power_set(Curry._1(g, undefined));
}

function of_list$1(l, param) {
  return of_list(l);
}

function to_rev_list$1(e) {
  return to_rev_list(Curry._1(e, undefined));
}

function to_list$1(e) {
  var gen = Curry._1(e, undefined);
  return List.rev(to_rev_list(gen));
}

function to_array$1(e) {
  return to_array(Curry._1(e, undefined));
}

function of_array$1(start, len, a, param) {
  return of_array(start, len, a);
}

function of_string$1(start, len, s, param) {
  return of_string(start, len, s);
}

function to_string$1(s) {
  return to_string(Curry._1(s, undefined));
}

function to_buffer$1(buf, s) {
  var g = Curry._1(s, undefined);
  return iter((function (param) {
                return $$Buffer.add_char(buf, param);
              }), g);
}

function rand_int$1(i, param) {
  return function (param) {
    return Caml_option.some(Random.$$int(i));
  };
}

function int_range$1(step, i, j, param) {
  return int_range(step, i, j);
}

function lines$1(g, param) {
  return lines(Curry._1(g, undefined));
}

function unlines$1(g, param) {
  return unlines(Curry._1(g, undefined));
}

var partial_arg$1 = 1;

function $neg$neg$1(param, param$1, param$2) {
  return int_range(partial_arg$1, param, param$1);
}

function $great$great$eq$1(x, f) {
  return function (param) {
    return flat_map(f, Curry._1(x, undefined));
  };
}

function $great$great$pipe$1(x, f) {
  return function (param) {
    return map(f, Curry._1(x, undefined));
  };
}

function $great$pipe$eq$1(x, f) {
  return function (param) {
    return map(f, Curry._1(x, undefined));
  };
}

var Infix$1 = {
  $neg$neg: $neg$neg$1,
  $great$great$eq: $great$great$eq$1,
  $great$great$pipe: $great$great$pipe$1,
  $great$pipe$eq: $great$pipe$eq$1
};

function pp$1(start, stop, sep, horizontal, pp_elem, fmt, e) {
  return pp(start, stop, sep, horizontal, pp_elem, fmt, Curry._1(e, undefined));
}

function of_gen(caching, max_chunk_size, g) {
  var cached = {
    contents: undefined
  };
  return function (param) {
    var mlist = cached.contents;
    if (mlist !== undefined) {
      return GenMList$ReasonmlDemoIterators.to_gen(Caml_option.valFromOption(mlist));
    }
    var mlist$1 = GenMList$ReasonmlDemoIterators.of_gen_lazy(max_chunk_size, caching, g);
    cached.contents = Caml_option.some(mlist$1);
    return GenMList$ReasonmlDemoIterators.to_gen(mlist$1);
  };
}

var Restart = {
  lift: lift,
  lift2: lift2,
  empty: empty$2,
  singleton: singleton$1,
  $$return: singleton$1,
  iterate: iterate$1,
  repeat: repeat$1,
  unfold: unfold$1,
  init: init$1,
  cycle: cycle,
  is_empty: is_empty$2,
  fold: fold$1,
  reduce: reduce$1,
  scan: scan$1,
  unfold_scan: unfold_scan$1,
  iter: iter$1,
  iteri: iteri$1,
  length: length$1,
  map: map$1,
  mapi: mapi$1,
  fold_map: fold_map$1,
  append: append$1,
  flatten: flatten$1,
  flat_map: flat_map$1,
  mem: mem$1,
  take: take$1,
  drop: drop$1,
  nth: nth$1,
  take_nth: take_nth$1,
  filter: filter$1,
  take_while: take_while$1,
  fold_while: fold_while$1,
  drop_while: drop_while$1,
  filter_map: filter_map$1,
  zip_with: zip_with$1,
  zip: zip$1,
  zip_index: zip_index$1,
  unzip: unzip$1,
  partition: partition$1,
  for_all: for_all$1,
  exists: exists$1,
  for_all2: for_all2$1,
  exists2: exists2$1,
  map2: map2$1,
  iter2: iter2$1,
  fold2: fold2$1,
  min: min$1,
  max: max$1,
  ___eq: eq,
  eq: eq$1,
  lexico: lexico$1,
  compare: compare$1,
  sum: sum$1,
  find: find$1,
  merge: merge$1,
  intersection: intersection$1,
  sorted_merge: sorted_merge$1,
  sorted_merge_n: sorted_merge_n$1,
  tee: tee$1,
  round_robin: round_robin$1,
  interleave: interleave$1,
  intersperse: intersperse$1,
  product: product$1,
  group: group$1,
  uniq: uniq$1,
  sort: sort$1,
  sort_uniq: sort_uniq$1,
  chunks: chunks$1,
  permutations: permutations$1,
  permutations_heap: permutations_heap$1,
  combinations: combinations$1,
  power_set: power_set$1,
  of_list: of_list$1,
  to_rev_list: to_rev_list$1,
  to_list: to_list$1,
  to_array: to_array$1,
  of_array: of_array$1,
  of_string: of_string$1,
  to_string: to_string$1,
  to_buffer: to_buffer$1,
  rand_int: rand_int$1,
  int_range: int_range$1,
  lines: lines$1,
  unlines: unlines$1,
  Infix: Infix$1,
  $neg$neg: $neg$neg$1,
  $great$great$eq: $great$great$eq$1,
  $great$great$pipe: $great$great$pipe$1,
  $great$pipe$eq: $great$pipe$eq$1,
  pp: pp$1,
  of_gen: of_gen
};

function start(g) {
  return Curry._1(g, undefined);
}

function persistent(gen) {
  var l = GenMList$ReasonmlDemoIterators.of_gen(gen);
  return function (param) {
    return GenMList$ReasonmlDemoIterators.to_gen(l);
  };
}

function persistent_lazy(caching, max_chunk_size, gen) {
  var l = GenMList$ReasonmlDemoIterators.of_gen_lazy(max_chunk_size, caching, gen);
  return function (param) {
    return GenMList$ReasonmlDemoIterators.to_gen(l);
  };
}

function peek(g) {
  var state = {
    contents: "Start"
  };
  var next = function (_param) {
    while(true) {
      var match = state.contents;
      if (typeof match === "string") {
        if (match === "Stop") {
          return ;
        }
        var x = Curry._1(g, undefined);
        if (x !== undefined) {
          state.contents = {
            NAME: "At",
            VAL: Caml_option.valFromOption(x)
          };
          _param = undefined;
          continue ;
        }
        state.contents = "Stop";
        return ;
      }
      var x$1 = match.VAL;
      var res = Curry._1(g, undefined);
      if (res !== undefined) {
        state.contents = {
          NAME: "At",
          VAL: Caml_option.valFromOption(res)
        };
        return [
                x$1,
                res
              ];
      } else {
        state.contents = "Stop";
        return [
                x$1,
                undefined
              ];
      }
    };
  };
  return next;
}

function queue_to_array_(q) {
  if (Queue.is_empty(q)) {
    return [];
  }
  var x = Queue.peek(q);
  var a = Caml_array.caml_make_vect(Queue.length(q), x);
  var i = {
    contents: 0
  };
  Queue.iter((function (x) {
          Caml_array.set(a, i.contents, x);
          i.contents = i.contents + 1 | 0;
          
        }), q);
  return a;
}

function peek_n(n, g) {
  if (n < 1) {
    Pervasives.invalid_arg("peek_n");
  }
  var state = {
    contents: "Start"
  };
  var q = Queue.create(undefined);
  var next = function (_param) {
    while(true) {
      var match = state.contents;
      if (match === "Start") {
        fill(n);
        state.contents = Queue.is_empty(q) ? "Stop" : "Continue";
        _param = undefined;
        continue ;
      }
      if (match === "Stop") {
        return ;
      }
      if (Queue.is_empty(q)) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "gen.re",
                2491,
                6
              ],
              Error: new Error()
            };
      }
      var x = Queue.pop(q);
      fill(1);
      state.contents = Queue.is_empty(q) ? "Stop" : "Continue";
      return [
              x,
              queue_to_array_(q)
            ];
    };
  };
  var fill = function (_i) {
    while(true) {
      var i = _i;
      if ((i + Queue.length(q) | 0) > n) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "gen.re",
                2507,
                4
              ],
              Error: new Error()
            };
      }
      if (i <= 0) {
        return ;
      }
      var x = Curry._1(g, undefined);
      if (x === undefined) {
        return ;
      }
      Queue.push(Caml_option.valFromOption(x), q);
      _i = i - 1 | 0;
      continue ;
    };
  };
  return next;
}

function with_file_in(modeOpt, flagsOpt, filename, f) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : /* [] */0;
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, ic);
    Pervasives.close_in_noerr(ic);
    return x;
  }
  catch (e){
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function with_in(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, (function (param) {
                              try {
                                return Pervasives.input_char(ic);
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn.RE_EXN_ID === "End_of_file") {
                                  return ;
                                }
                                throw exn;
                              }
                            }));
              }));
}

function with_lines(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, (function (param) {
                              try {
                                return Pervasives.input_line(ic);
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn.RE_EXN_ID === "End_of_file") {
                                  return ;
                                }
                                throw exn;
                              }
                            }));
              }));
}

function with_file_out(modeOpt, flagsOpt, filename, f) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : ({
        hd: /* Open_creat */3,
        tl: {
          hd: /* Open_wronly */1,
          tl: /* [] */0
        }
      });
  var oc = Pervasives.open_out_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, oc);
    Pervasives.close_out(oc);
    return x;
  }
  catch (e){
    Pervasives.close_out_noerr(oc);
    throw e;
  }
}

function write_str(mode, flags, sepOpt, filename, g) {
  var sep = sepOpt !== undefined ? sepOpt : "";
  return with_file_out(mode, flags, filename, (function (oc) {
                return iteri((function (i, s) {
                              if (i > 0) {
                                Pervasives.output_string(oc, sep);
                              }
                              return Pervasives.output_string(oc, s);
                            }), g);
              }));
}

function write(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (c) {
                              return Pervasives.output_char(oc, c);
                            }), g);
              }));
}

function write_lines(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (s) {
                              Pervasives.output_string(oc, s);
                              return Pervasives.output_char(oc, /* "\n" */10);
                            }), g);
              }));
}

var IO = {
  with_file_in: with_file_in,
  with_in: with_in,
  with_lines: with_lines,
  with_file_out: with_file_out,
  write_str: write_str,
  write: write,
  write_lines: write_lines
};

var $$return = singleton;

exports.empty = empty;
exports.singleton = singleton;
exports.$$return = $$return;
exports.repeat = repeat;
exports.repeatedly = repeatedly;
exports.iterate = iterate;
exports.next = next;
exports.get = get;
exports.get_exn = get_exn;
exports.junk = junk;
exports.fold = fold;
exports.reduce = reduce;
exports.unfold = unfold;
exports.init = init;
exports.iter = iter;
exports.iteri = iteri;
exports.is_empty = is_empty;
exports.length = length;
exports.RunState = RunState;
exports.scan = scan;
exports.unfold_scan = unfold_scan;
exports.map = map;
exports.mapi = mapi;
exports.fold_map = fold_map;
exports.append = append;
exports.flatten = flatten;
exports.flat_map = flat_map;
exports.mem = mem;
exports.take = take;
exports.__drop = __drop;
exports.drop = drop;
exports.nth = nth;
exports.take_nth = take_nth;
exports.filter = filter;
exports.take_while = take_while;
exports.fold_while = fold_while;
exports.DropWhileState = DropWhileState;
exports.drop_while = drop_while;
exports.filter_map = filter_map;
exports.zip_index = zip_index;
exports.unzip = unzip;
exports.partition = partition;
exports.for_all = for_all;
exports.exists = exists;
exports.min = min;
exports.max = max;
exports.eq = eq;
exports.lexico = lexico;
exports.compare = compare;
exports.find = find;
exports.sum = sum;
exports.map2 = map2;
exports.iter2 = iter2;
exports.fold2 = fold2;
exports.for_all2 = for_all2;
exports.exists2 = exists2;
exports.zip_with = zip_with;
exports.zip = zip;
exports.MergeState = MergeState;
exports.merge = merge;
exports.intersection = intersection;
exports.sorted_merge = sorted_merge;
exports.Heap = Heap;
exports.sorted_merge_n = sorted_merge_n;
exports.round_robin = round_robin;
exports.tee = tee;
exports.InterleaveState = InterleaveState;
exports.interleave = interleave;
exports.IntersperseState = IntersperseState;
exports.intersperse = intersperse;
exports.product = product;
exports.group = group;
exports.uniq = uniq;
exports.sort = sort;
exports.sort_uniq = sort_uniq;
exports.chunks = chunks;
exports.PermState = PermState;
exports.permutations = permutations;
exports.HeapPermState = HeapPermState;
exports.permutations_heap = permutations_heap;
exports.CombState = CombState;
exports.combinations = combinations;
exports.PowerSetState = PowerSetState;
exports.power_set = power_set;
exports.of_list = of_list;
exports.to_rev_list = to_rev_list;
exports.to_list = to_list;
exports.to_array = to_array;
exports.of_array = of_array;
exports.of_string = of_string;
exports.to_buffer = to_buffer;
exports.to_string = to_string;
exports.rand_int = rand_int;
exports.int_range = int_range;
exports.lines = lines;
exports.unlines = unlines;
exports.pp = pp;
exports.Infix = Infix;
exports.$neg$neg = $neg$neg;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.$great$pipe$eq = $great$pipe$eq;
exports.Restart = Restart;
exports.start = start;
exports.persistent = persistent;
exports.persistent_lazy = persistent_lazy;
exports.peek = peek;
exports.queue_to_array_ = queue_to_array_;
exports.peek_n = peek_n;
exports.IO = IO;
/* Format Not a pure module */
