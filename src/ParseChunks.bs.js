// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                      = require("bs-platform/lib/js/list.js");
var Curry                     = require("bs-platform/lib/js/curry.js");
var Caml_array                = require("bs-platform/lib/js/caml_array.js");
var Js_primitive              = require("bs-platform/lib/js/js_primitive.js");
var Gen$ReasonmlDemoIterators = require("./lib/gen/gen.bs.js");

var titleRegex = (/^## (.*)$/);

function extractTitle(line) {
  var match = titleRegex.exec(line);
  if (match !== null) {
    return Js_primitive.null_undefined_to_opt(Caml_array.caml_array_get(match, 1));
  } else {
    return /* None */0;
  }
}

function appendLine(line, ch) {
  return /* record */[
          /* title */ch[/* title */0],
          /* body : :: */[
            line,
            ch[/* body */1]
          ]
        ];
}

function reverseLines(ch) {
  return /* record */[
          /* title */ch[/* title */0],
          /* body */List.rev(ch[/* body */1])
        ];
}

function toOptChunk(ch) {
  if (List.length(ch[/* body */1])) {
    return /* Some */[reverseLines(ch)];
  } else {
    return /* None */0;
  }
}

function unfoldScanFunc(state, line) {
  var match = extractTitle(line);
  if (match) {
    var nextState_000 = /* title */match[0];
    var nextState_001 = /* body : :: */[
      line,
      /* [] */0
    ];
    var nextState = /* record */[
      nextState_000,
      nextState_001
    ];
    var output = toOptChunk(state);
    return /* tuple */[
            nextState,
            output
          ];
  } else {
    var nextState$1 = appendLine(line, state);
    return /* tuple */[
            nextState$1,
            /* None */0
          ];
  }
}

function linesToChunks(lines) {
  var sentinel = Gen$ReasonmlDemoIterators.singleton("## Will be discarded");
  var linesWithSentinel = Gen$ReasonmlDemoIterators.append(lines, sentinel);
  var genWithOpts = Gen$ReasonmlDemoIterators.unfold_scan(unfoldScanFunc, /* record */[
        /* title */"PREFIX",
        /* body : [] */0
      ], linesWithSentinel);
  return Gen$ReasonmlDemoIterators.filter_map((function (x) {
                return x;
              }), genWithOpts);
}

function linesToChunksImp(lines) {
  var lineOpt = Curry._1(lines, /* () */0);
  var init;
  if (lineOpt) {
    var line = lineOpt[0];
    var match = extractTitle(line);
    var title = match ? match[0] : "PREFIX";
    init = /* Some */[/* record */[
        /* title */title,
        /* body : :: */[
          line,
          /* [] */0
        ]
      ]];
  } else {
    init = /* None */0;
  }
  var curChunkOpt = [init];
  return (function () {
      var _param = /* () */0;
      while(true) {
        var match = curChunkOpt[0];
        if (match) {
          var curChunk = match[0];
          var lineOpt = Curry._1(lines, /* () */0);
          if (lineOpt) {
            var line = lineOpt[0];
            var match$1 = extractTitle(line);
            if (match$1) {
              curChunkOpt[0] = /* Some */[/* record */[
                  /* title */match$1[0],
                  /* body : :: */[
                    line,
                    /* [] */0
                  ]
                ]];
              return /* Some */[reverseLines(curChunk)];
            } else {
              curChunkOpt[0] = /* Some */[appendLine(line, curChunk)];
              _param = /* () */0;
              continue ;
              
            }
          } else {
            curChunkOpt[0] = /* None */0;
            return /* Some */[reverseLines(curChunk)];
          }
        } else {
          return /* None */0;
        }
      };
    });
}

exports.titleRegex       = titleRegex;
exports.extractTitle     = extractTitle;
exports.appendLine       = appendLine;
exports.reverseLines     = reverseLines;
exports.toOptChunk       = toOptChunk;
exports.unfoldScanFunc   = unfoldScanFunc;
exports.linesToChunks    = linesToChunks;
exports.linesToChunksImp = linesToChunksImp;
/* titleRegex Not a pure module */
